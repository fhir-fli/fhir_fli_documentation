"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[519],{3334:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=n(4848),s=n(8453);const l={id:"polymorphic_types",title:"Polymprhic Types"},a="Polymorphic Types in FHIR-FLI",r={id:"core/polymorphic_types",title:"Polymprhic Types",description:"Understanding Polymorphic Fields",source:"@site/docs/core/polymorphic_types.md",sourceDirName:"core",slug:"/core/polymorphic_types",permalink:"/fhir_fli_documentation/docs/core/polymorphic_types",draft:!1,unlisted:!1,editUrl:"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/core/polymorphic_types.md",tags:[],version:"current",frontMatter:{id:"polymorphic_types",title:"Polymprhic Types"},sidebar:"tutorialSidebar",previous:{title:"Class Structure",permalink:"/fhir_fli_documentation/docs/core/class_structure"},next:{title:"Primitive Types",permalink:"/fhir_fli_documentation/docs/core/primitive_types"}},c={},d=[{value:"Understanding Polymorphic Fields",id:"understanding-polymorphic-fields",level:2},{value:"How FHIR-FLI Handles Polymorphism",id:"how-fhir-fli-handles-polymorphism",level:2},{value:"1. The &quot;X&quot; Naming Convention",id:"1-the-x-naming-convention",level:3},{value:"2. Abstract Base Classes",id:"2-abstract-base-classes",level:3},{value:"3. Type-Specific Getters",id:"3-type-specific-getters",level:3},{value:"Working with Polymorphic Fields",id:"working-with-polymorphic-fields",level:2},{value:"Setting Values",id:"setting-values",level:3},{value:"Checking and Accessing Types",id:"checking-and-accessing-types",level:3},{value:"1. Using type-specific getters:",id:"1-using-type-specific-getters",level:4},{value:"2. Using the isAs&lt;T&gt;() method:",id:"2-using-the-isast-method",level:4},{value:"3. Using type checking:",id:"3-using-type-checking",level:4},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Example with Polymorphic Types",id:"example-with-polymorphic-types",level:2}];function o(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"polymorphic-types-in-fhir-fli",children:"Polymorphic Types in FHIR-FLI"}),"\n",(0,t.jsx)(i.h2,{id:"understanding-polymorphic-fields",children:"Understanding Polymorphic Fields"}),"\n",(0,t.jsx)(i.p,{children:"FHIR resources often include polymorphic fields - fields that can contain different types of data depending on the context. For example, a field might accept a date, a datetime, a period, or even a string in different scenarios. This flexibility is powerful but creates implementation challenges, especially in strongly-typed languages like Dart."}),"\n",(0,t.jsx)(i.h2,{id:"how-fhir-fli-handles-polymorphism",children:"How FHIR-FLI Handles Polymorphism"}),"\n",(0,t.jsx)(i.p,{children:"FHIR-FLI uses a consistent approach to handle polymorphic fields through abstract classes and clear naming conventions:"}),"\n",(0,t.jsx)(i.h3,{id:"1-the-x-naming-convention",children:'1. The "X" Naming Convention'}),"\n",(0,t.jsxs)(i.p,{children:['Polymorphic fields in FHIR-FLI are typically named with an "X" suffix (e.g., ',(0,t.jsx)(i.code,{children:"scheduledX"}),", ",(0,t.jsx)(i.code,{children:"productX"}),", ",(0,t.jsx)(i.code,{children:"subjectX"}),"). This naming convention clearly indicates that the field can contain multiple possible types."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Example from CarePlanDetail class\nfinal ScheduledXCarePlanDetail? scheduledX;\nfinal ProductXCarePlanDetail? productX;\n"})}),"\n",(0,t.jsx)(i.h3,{id:"2-abstract-base-classes",children:"2. Abstract Base Classes"}),"\n",(0,t.jsx)(i.p,{children:"For each polymorphic field, FHIR-FLI defines an abstract class that all potential types for that field will implement:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Example abstract class (simplified)\nabstract class ScheduledXCarePlanDetail implements FhirBase {\n  // Common interface methods\n}\n\n// Classes that can be used in this field\nclass Timing implements ScheduledXCarePlanDetail { ... }\nclass Period implements ScheduledXCarePlanDetail { ... }\nclass FhirString implements ScheduledXCarePlanDetail { ... }\n"})}),"\n",(0,t.jsx)(i.p,{children:"This approach allows the compiler to verify type safety while maintaining flexibility."}),"\n",(0,t.jsx)(i.h3,{id:"3-type-specific-getters",children:"3. Type-Specific Getters"}),"\n",(0,t.jsx)(i.p,{children:"To make working with polymorphic fields more intuitive, FHIR-FLI includes type-specific getter methods that return the value only if it matches the requested type:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Getters for the scheduledX field in CarePlanDetail\nTiming? get scheduledTiming => scheduledX?.isAs<Timing>();\nPeriod? get scheduledPeriod => scheduledX?.isAs<Period>();\nFhirString? get scheduledString => scheduledX?.isAs<FhirString>();\n"})}),"\n",(0,t.jsx)(i.p,{children:"These getters make it easy to access the field in its correct type without worrying about type casting or runtime errors."}),"\n",(0,t.jsx)(i.h2,{id:"working-with-polymorphic-fields",children:"Working with Polymorphic Fields"}),"\n",(0,t.jsx)(i.h3,{id:"setting-values",children:"Setting Values"}),"\n",(0,t.jsx)(i.p,{children:"When creating or updating a FHIR resource, you can directly use any valid type for a polymorphic field:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Setting a polymorphic field with a specific type\nfinal carePlanDetail = CarePlanDetail(\n  status: CarePlanActivityStatus.active,\n  scheduledX: Timing(\n    repeat: TimingRepeat(\n      frequency: FhirPositiveInt(1),\n      period: FhirDecimal(1),\n      periodUnit: UnitsOfTime.d,\n    ),\n  ),\n  // Other fields...\n);\n\n// Alternatively, create with a different type\nfinal anotherCarePlanDetail = CarePlanDetail(\n  status: CarePlanActivityStatus.active,\n  scheduledX: Period(\n    start: FhirDateTime('2023-01-01'),\n    end: FhirDateTime('2023-12-31'),\n  ),\n  // Other fields...\n);\n"})}),"\n",(0,t.jsx)(i.p,{children:"The library handles the proper serialization and deserialization based on the type provided."}),"\n",(0,t.jsx)(i.h3,{id:"checking-and-accessing-types",children:"Checking and Accessing Types"}),"\n",(0,t.jsx)(i.p,{children:"You can check the specific type of a polymorphic field and access it in several ways:"}),"\n",(0,t.jsx)(i.h4,{id:"1-using-type-specific-getters",children:"1. Using type-specific getters:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Check if scheduledX is a Timing and access it\nif (carePlanDetail.scheduledTiming != null) {\n  final timing = carePlanDetail.scheduledTiming;\n  // Work with timing...\n}\n"})}),"\n",(0,t.jsx)(i.h4,{id:"2-using-the-isast-method",children:"2. Using the isAs<T>() method:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Check if productX is a CodeableConcept\nif (carePlanDetail.productX?.isAs<CodeableConcept>() != null) {\n  final concept = carePlanDetail.productX!.isAs<CodeableConcept>()!;\n  // Work with concept...\n}\n"})}),"\n",(0,t.jsx)(i.h4,{id:"3-using-type-checking",children:"3. Using type checking:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"if (carePlanDetail.productX is CodeableConcept) {\n  final concept = carePlanDetail.productX as CodeableConcept;\n  // Work with concept...\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Single Type Limitation"}),": A polymorphic field can only contain one type at a time. For example, if ",(0,t.jsx)(i.code,{children:"scheduledX"})," contains a ",(0,t.jsx)(i.code,{children:"Timing"}),", it cannot simultaneously contain a ",(0,t.jsx)(i.code,{children:"Period"})," or ",(0,t.jsx)(i.code,{children:"FhirString"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Type Safety"}),": The abstract class implementation ensures that only valid types can be assigned to polymorphic fields, providing compile-time type safety."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Naming Patterns"}),": When searching for fields by name, you can use:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:['The base field name with an "X" suffix (e.g., ',(0,t.jsx)(i.code,{children:"scheduledX"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:["The specific type name (e.g., ",(0,t.jsx)(i.code,{children:"scheduledTiming"}),", ",(0,t.jsx)(i.code,{children:"scheduledPeriod"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:["For ",(0,t.jsx)(i.code,{children:"getChildrenByName()"}),", using the specific type name will only return values if the field contains that specific type"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Serialization"}),": When serialized to JSON, the field will be appropriately labeled based on its type, following the FHIR specification."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"example-with-polymorphic-types",children:"Example with Polymorphic Types"}),"\n",(0,t.jsxs)(i.p,{children:["Here's a complete example showing how to work with the polymorphic ",(0,t.jsx)(i.code,{children:"scheduledX"})," field in ",(0,t.jsx)(i.code,{children:"CarePlanDetail"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-dart",children:"// Create a CarePlanDetail with a Timing scheduledX\nfinal carePlanWithTiming = CarePlanDetail(\n  status: CarePlanActivityStatus.active,\n  scheduledX: Timing(\n    repeat: TimingRepeat(\n      frequency: FhirPositiveInt(2),\n      periodUnit: UnitsOfTime.d,\n    ),\n  ),\n);\n\n// Create a CarePlanDetail with a Period scheduledX\nfinal carePlanWithPeriod = CarePlanDetail(\n  status: CarePlanActivityStatus.active,\n  scheduledX: Period(\n    start: FhirDateTime('2023-01-01'),\n    end: FhirDateTime('2023-12-31'),\n  ),\n);\n\n// Accessing the values safely\nvoid processSchedule(CarePlanDetail detail) {\n  // Approach 1: Using specific getters\n  if (detail.scheduledTiming != null) {\n    print('This is a timing-based schedule');\n    final frequency = detail.scheduledTiming?.repeat?.frequency?.value;\n    print('Frequency: $frequency times');\n  } else if (detail.scheduledPeriod != null) {\n    print('This is a period-based schedule');\n    final start = detail.scheduledPeriod?.start?.value;\n    final end = detail.scheduledPeriod?.end?.value;\n    print('Period: $start to $end');\n  } else if (detail.scheduledString != null) {\n    print('This is a string-based schedule');\n    print('Description: ${detail.scheduledString?.value}');\n  }\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:"This approach to polymorphic types allows FHIR-FLI to accurately represent the flexibility of the FHIR specification while maintaining the benefits of Dart's strong typing system."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>r});var t=n(6540);const s={},l=t.createContext(s);function a(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);