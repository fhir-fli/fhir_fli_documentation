"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[931],{8124:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var t=i(4848),o=i(8453);const a={id:"serialization",title:"Serialization/Deserialization"},r="Serialization and Deserialization in FHIR-FLI",s={id:"core/serialization",title:"Serialization/Deserialization",description:"Serialization and deserialization are core functionalities in the FHIR-FLI libraries that enable conversion between FHIR resources (represented as Dart objects) and various data formats (mostly JSON, but John likes YAML). This page explains how these processes work in FHIR-FLI and how to use them effectively in your Flutter applications.",source:"@site/docs/core/serialization.md",sourceDirName:"core",slug:"/core/serialization",permalink:"/fhir_fli_documentation/docs/core/serialization",draft:!1,unlisted:!1,editUrl:"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/core/serialization.md",tags:[],version:"current",frontMatter:{id:"serialization",title:"Serialization/Deserialization"},sidebar:"tutorialSidebar",previous:{title:"Basics of FHIR Classes",permalink:"/fhir_fli_documentation/docs/core/basic_object"},next:{title:"Class Structure",permalink:"/fhir_fli_documentation/docs/core/class_structure"}},l={},c=[{value:"Concepts",id:"concepts",level:2},{value:"Serialization",id:"serialization",level:3},{value:"Deserialization",id:"deserialization",level:3},{value:"Working with JSON",id:"working-with-json",level:2},{value:"Serializing to JSON",id:"serializing-to-json",level:3},{value:"Serializing to YAML",id:"serializing-to-yaml",level:3},{value:"Deserializing from JSON",id:"deserializing-from-json",level:3},{value:"fromJsonString Constructor",id:"fromjsonstring-constructor",level:4}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"serialization-and-deserialization-in-fhir-fli",children:"Serialization and Deserialization in FHIR-FLI"}),"\n",(0,t.jsxs)(n.p,{children:["Serialization and deserialization are core functionalities in the FHIR-FLI libraries that enable conversion between FHIR resources (represented as Dart objects) and various data formats (mostly JSON, but ",(0,t.jsx)(n.a,{href:"https://github.com/FireJuun",children:"John"})," likes YAML). This page explains how these processes work in FHIR-FLI and how to use them effectively in your Flutter applications."]}),"\n",(0,t.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"serialization",children:"Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["Serialization is the process of converting a Dart object instance into a format that can be easily stored or transmitted, such as JSON (note, FHIR also supports XML and Turtle, we do not. We do support YAML, which is just a superset of JSON anyway). In FHIR-FLI, this means converting a FHIR resource object (like ",(0,t.jsx)(n.code,{children:"Patient"}),", ",(0,t.jsx)(n.code,{children:"Observation"}),", or ",(0,t.jsx)(n.code,{children:"Account"}),") into a JSON string."]}),"\n",(0,t.jsx)(n.h3,{id:"deserialization",children:"Deserialization"}),"\n",(0,t.jsx)(n.p,{children:"Deserialization is the reverse process - converting data from JSON format back into Dart objects that your application can work with directly."}),"\n",(0,t.jsx)(n.h2,{id:"working-with-json",children:"Working with JSON"}),"\n",(0,t.jsx)(n.p,{children:"JSON (JavaScript Object Notation) is the primary data interchange format for FHIR resources. FHIR-FLI provides robust support for JSON serialization and deserialization."}),"\n",(0,t.jsx)(n.h3,{id:"serializing-to-json",children:"Serializing to JSON"}),"\n",(0,t.jsxs)(n.p,{children:["Every FHIR resource class in FHIR-FLI implements a ",(0,t.jsx)(n.code,{children:"toJson()"})," method that converts the object to a Map representation, which can then be converted to a JSON string. So if we take our patient example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final patient = Patient(\n    id: FhirString('123'),\n    name: [\n      HumanName(\n        family: 'Doe'.toFhirString,\n        given: ['John'.toFhirString],\n      ),\n    ],\n    birthDate: '1990-01-01'.toFhirDate,\n  );\n\nprint(patient.toJson());\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ {resourceType: Patient, id: 123, name: [{family: Doe, given: [John]}], birthDate: 1990-01-01}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Which is correct. And while there are some occasions where it may be useful to see that, you're usually going to be working with the Dart class OR you're going to need to change it into a JSON String representation, which is how JSON is actually transferred. So if we instead do this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"print(jsonEncode(patient.toJson()));\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ {"resourceType":"Patient","id":"123","name":[{"family":"Doe","given":["John"]}],"birthDate":"1990-01-01"}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["And that's what you would actually transmit via a POST request for instance. You do a lot of that in FHIR, and I found it cumbersome to have to do two steps. So in addition to a ",(0,t.jsx)(n.code,{children:"toJson()"})," method, all FHIR classes have a ",(0,t.jsx)(n.code,{children:"toJsonString()"})," method, that does both parts."]}),"\n",(0,t.jsx)(n.h3,{id:"serializing-to-yaml",children:"Serializing to YAML"}),"\n",(0,t.jsx)(n.p,{children:"I'm not going to talk about this alot, the idea is very much the same as the above, except that it works for YAML strings. Most FHIR servers will not accept YAML strings, but we have found it useful at times when you want a prettier or cleaner way to display FHIR data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"print(patient.toYaml());\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"resourceType: Patient\nid: '123'\nname:\n  - family: Doe\n    given:\n      - John\nbirthDate: \"1990-01-01\"\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deserializing-from-json",children:"Deserializing from JSON"}),"\n",(0,t.jsx)(n.p,{children:"This is the reverse process as above. You will typically use this when you're accepting data from an outside source (a database, a server, etc.). While all classes have this function, you typically need to know what class it is. The library is not smart enough to let you take a random Map and turn it into FHIR, you have to provide it with a bit of instruction."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final name = {\n    'family': 'Doe',\n    'given': ['Jane']\n}\n\nfinal humanName = HumanName.fromJson(name);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The one exception is if its a Resource. Since a FHIR Resource is the basic building block of the specification, Resources are treated slightly differently. If you know that something is a Resource, even if you don't know what kind, we can still work with that."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:'final resource1 = {\n  "resourceType": "Patient",\n  "name": [\n    {\n      "family": "Doe",\n      "given": ["Jane"]\n    }\n  ],\n};\n\nfinal resource2 = {\n  "resourceType": "Observation",\n  "status": "final",\n  "code": {\n    "text": "Blood Pressure"\n  },\n  "valueQuantity": {\n    "value": 120,\n    "unit": "mmHg"\n  }\n};\n\n\nfinal unknownResource1 = Resource.fromJson(resource1);\nfinal unknownResource2 = Resource.fromJson(resource2);\n\nprint(unknownResource1 is Patient); // true\nprint(unknownResource2 is Observation); // true\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is based on the resourceType field, so that does need to be present (which if it's from a server or db it should be). But if for some reason you're writing your own maps and don't include the resourceType field, it won't work."}),"\n",(0,t.jsx)(n.h4,{id:"fromjsonstring-constructor",children:"fromJsonString Constructor"}),"\n",(0,t.jsxs)(n.p,{children:["Similarly to the fromJson constructor we talked about above, there's also a convenience constructor ",(0,t.jsx)(n.code,{children:"fromJsonString"})," for all classes. What this means is that if you have a string from a GET request, you can pass it directly to the constructor, you don't have to convert it into a map first. You're welcome."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);