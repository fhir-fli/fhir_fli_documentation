"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[283],{72:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var i=r(4848),a=r(8453);const t={id:"fhir_mapping_engine",title:"FHIR Mapping Engine"},s="FHIR Mapping Engine in FHIR-FLI",o={id:"mapping/fhir_mapping_engine",title:"FHIR Mapping Engine",description:"Understanding the Mapping Engine",source:"@site/docs/mapping/fhir_mapping_engine.md",sourceDirName:"mapping",slug:"/mapping/fhir_mapping_engine",permalink:"/fhir_fli_documentation/docs/mapping/fhir_mapping_engine",draft:!1,unlisted:!1,editUrl:"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/mapping/fhir_mapping_engine.md",tags:[],version:"current",frontMatter:{id:"fhir_mapping_engine",title:"FHIR Mapping Engine"},sidebar:"tutorialSidebar",previous:{title:"FHIR Map Parser",permalink:"/fhir_fli_documentation/docs/mapping/fhirmap_parsing"}},c={},l=[{value:"Understanding the Mapping Engine",id:"understanding-the-mapping-engine",level:2},{value:"Key Components of the Mapping System",id:"key-components-of-the-mapping-system",level:2},{value:"Resource Cache Hierarchy",id:"resource-cache-hierarchy",level:3},{value:"1. ResourceCache (Base Abstract Class)",id:"1-resourcecache-base-abstract-class",level:4},{value:"2. CanonicalResourceCache",id:"2-canonicalresourcecache",level:4},{value:"3. OnlineResourceCache",id:"3-onlineresourcecache",level:4},{value:"Resource Builders",id:"resource-builders",level:3},{value:"Creating and Using the Mapping Engine",id:"creating-and-using-the-mapping-engine",level:2},{value:"Engine Creation",id:"engine-creation",level:3},{value:"Basic Transformation",id:"basic-transformation",level:3},{value:"Working with Builders",id:"working-with-builders",level:3},{value:"Extended Type Creation",id:"extended-type-creation",level:3},{value:"Advanced Mapping Features",id:"advanced-mapping-features",level:2},{value:"Working with Different Resource Caches",id:"working-with-different-resource-caches",level:3},{value:"Handling Transformation Context",id:"handling-transformation-context",level:3},{value:"Pre-loading Required Resources",id:"pre-loading-required-resources",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Testing Mappings",id:"testing-mappings",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"fhir-mapping-engine-in-fhir-fli",children:"FHIR Mapping Engine in FHIR-FLI"}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-mapping-engine",children:"Understanding the Mapping Engine"}),"\n",(0,i.jsx)(n.p,{children:"The FHIR Mapping Engine is the component that executes StructureMap resources to transform data from one format to another. It implements the FHIR mapping standard, handling complex transformations while ensuring type safety and correctness."}),"\n",(0,i.jsx)(n.h2,{id:"key-components-of-the-mapping-system",children:"Key Components of the Mapping System"}),"\n",(0,i.jsx)(n.h3,{id:"resource-cache-hierarchy",children:"Resource Cache Hierarchy"}),"\n",(0,i.jsx)(n.p,{children:"The mapping engine relies on a cache system to efficiently access and store canonical resources. FHIR-FLI provides three levels of resource caching:"}),"\n",(0,i.jsx)(n.h4,{id:"1-resourcecache-base-abstract-class",children:"1. ResourceCache (Base Abstract Class)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"abstract class ResourceCache {\n  // Abstract methods for resource lookup\n  Future<Resource?> findResourceById(String resourceType, String id);\n  Future<Resource?> findResourceByUrl(String url);\n  \n  // Other abstract methods...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The base ",(0,i.jsx)(n.code,{children:"ResourceCache"})," defines the interface for resource lookup operations. As an abstract class, it can't be instantiated directly."]}),"\n",(0,i.jsx)(n.h4,{id:"2-canonicalresourcecache",children:"2. CanonicalResourceCache"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class CanonicalResourceCache extends ResourceCache {\n  // Implementation of resource caching with local storage\n  \n  // Save a resource to the local cache\n  void saveCanonicalResource(Resource resource) {\n    // Implementation...\n  }\n  \n  // Other implemented methods...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This implementation provides local, in-memory caching of canonical resources. It only returns resources that have been explicitly stored in the cache."}),"\n",(0,i.jsx)(n.h4,{id:"3-onlineresourcecache",children:"3. OnlineResourceCache"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class OnlineResourceCache extends CanonicalResourceCache {\n  // Implementation with both local caching and online lookup\n  \n  @override\n  Future<Resource?> findResourceByUrl(String url) async {\n    // First try local cache\n    final localResource = await super.findResourceByUrl(url);\n    if (localResource != null) {\n      return localResource;\n    }\n    \n    // If not found locally, try to fetch from online source\n    // Implementation...\n  }\n  \n  // Other implemented methods...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This extends the ",(0,i.jsx)(n.code,{children:"CanonicalResourceCache"})," to add online lookup capabilities. If a resource isn't found in the local cache, it will attempt to fetch it from designated online endpoints."]}),"\n",(0,i.jsx)(n.h3,{id:"resource-builders",children:"Resource Builders"}),"\n",(0,i.jsx)(n.p,{children:"FHIR resources are typically immutable and often have required fields. During mapping, resources need to be built incrementally, which creates challenges:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A resource might not have all required fields until mapping is complete"}),"\n",(0,i.jsx)(n.li,{children:"Mapping rules may need to modify fields during execution"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"To address this, FHIR-FLI implements the Builder pattern with classes that mirror FHIR resources:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Normal immutable FHIR class\nclass Patient implements Resource {\n  Patient({\n    required this.name,  // Required field\n    this.gender,\n  });\n  \n  final List<HumanName> name;\n  final FhirCode<PatientGender>? gender;\n  \n  // Other fields and methods...\n}\n\n// Mutable builder version\nclass PatientBuilder implements ResourceBuilder {\n  PatientBuilder();\n  \n  List<HumanNameBuilder>? name;  // No longer required, can be nullable\n  FhirCode<PatientGender>? gender;\n  \n  // Convert to immutable FHIR resource when complete\n  Patient toResource() {\n    // Validate required fields\n    if (name == null || name!.isEmpty) {\n      throw Exception('Required field missing: name');\n    }\n    \n    // Convert builders to immutable objects\n    final nameResources = name!.map((n) => n.toResource()).toList();\n    \n    // Return immutable resource\n    return Patient(\n      name: nameResources,\n      gender: gender,\n    );\n  }\n  \n  // Other methods...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Key characteristics of builders:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No required fields"}),"\n",(0,i.jsx)(n.li,{children:"All fields are nullable"}),"\n",(0,i.jsx)(n.li,{children:"Fields are mutable"}),"\n",(0,i.jsx)(n.li,{children:"Provide methods to convert to immutable resources"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-and-using-the-mapping-engine",children:"Creating and Using the Mapping Engine"}),"\n",(0,i.jsx)(n.h3,{id:"engine-creation",children:"Engine Creation"}),"\n",(0,i.jsx)(n.p,{children:"Like the parser, the mapping engine must be created asynchronously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Create a resource cache\nfinal resourceCache = CanonicalResourceCache();\n\n// Load a StructureMap (possibly from the parser)\nfinal structureMap = /* your StructureMap */;\n\n// Create the mapping engine\nfinal mapEngine = await FhirMapEngine.create(resourceCache, structureMap);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"basic-transformation",children:"Basic Transformation"}),"\n",(0,i.jsxs)(n.p,{children:["The simplest way to transform data is with the ",(0,i.jsx)(n.code,{children:"transform"})," or ",(0,i.jsx)(n.code,{children:"transformFromFhir"})," methods:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Transform a source resource to a target using the loaded map\nFuture<Resource> transformPatientToPerson(Patient patient) async {\n  // If no target is provided, one will be created based on the map's target type\n  final result = await mapEngine.transformFromFhir(\n    patient,          // Source resource\n    structureMap,     // The StructureMap to use\n    null,             // Optional target resource (null means create new)\n  );\n  \n  // Cast the result to the expected type\n  return result as Person;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-builders",children:"Working with Builders"}),"\n",(0,i.jsx)(n.p,{children:"For more control or when dealing with partially constructed resources, you can work directly with builders:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Future<Resource?> transformWithBuilders(\n  FhirBaseBuilder source,\n  StructureMap map,\n  FhirBaseBuilder? target,\n) async {\n  // Create the engine\n  final mapEngine = await FhirMapEngine.create(resourceCache, map);\n  \n  // Transform using builders\n  final transformedBuilder = await mapEngine.transformBuilder(\n    '',        // Optional group name (empty uses the default group)\n    source,    // Source resource builder\n    map,       // The StructureMap to use\n    target,    // Target resource builder (can be null)\n  );\n  \n  // Convert the builder to a resource if transformation succeeded\n  return transformedBuilder?.build();\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extended-type-creation",children:"Extended Type Creation"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes mapping needs to create resources dynamically based on type names. You can provide a callback to handle custom resource creation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Define a function to create empty builders for custom types\nFhirBaseBuilder? customEmptyFromType(String type) {\n  final fhirType = type.toLowerCase();\n  switch (fhirType) {\n    case 'mycustomtype':\n      return MyCustomTypeBuilder.empty();\n    case 'anothercustomtype':\n      return AnotherCustomTypeBuilder.empty();\n    default:\n      return null;  // Let the default handler try\n  }\n}\n\n// Set the callback on the engine\nmapEngine.extendedEmptyFromType = customEmptyFromType;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-mapping-features",children:"Advanced Mapping Features"}),"\n",(0,i.jsx)(n.h3,{id:"working-with-different-resource-caches",children:"Working with Different Resource Caches"}),"\n",(0,i.jsx)(n.p,{children:"You can select the appropriate resource cache based on your needs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// For local-only operation\nfinal localCache = CanonicalResourceCache();\nlocalCache.saveCanonicalResource(structureDefinitionA);\nlocalCache.saveCanonicalResource(valueSetB);\n\n// For mixed local/online operation\nfinal onlineCache = OnlineResourceCache();\nonlineCache.saveCanonicalResource(structureDefinitionA);  // Priority local cache\n// Other resources will be fetched from online sources if needed\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-transformation-context",children:"Handling Transformation Context"}),"\n",(0,i.jsx)(n.p,{children:"The mapping engine maintains a transformation context during execution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// The context is created automatically during engine creation\nfinal context = TransformationContext(resolver);\n\n// You can access the context during or after mapping\nfinal generatedResources = context.getGeneratedResources();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pre-loading-required-resources",children:"Pre-loading Required Resources"}),"\n",(0,i.jsx)(n.p,{children:"For optimal performance, pre-load resources the mapping will need:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Pre-load structure definitions\nfinal resourceCache = CanonicalResourceCache()\n  ..saveCanonicalResource(structureDefinitionA)\n  ..saveCanonicalResource(structureDefinitionB)\n  ..saveCanonicalResource(valueSetC);\n\n// Create the engine with the pre-loaded cache\nfinal mapEngine = await FhirMapEngine.create(resourceCache, structureMap);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a complete example that demonstrates the mapping process:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_mapping/fhir_r4_mapping.dart';\n\nFuture<void> main() async {\n  // Step 1: Set up resource cache\n  final resourceCache = OnlineResourceCache();\n  \n  // Step 2: Pre-load any local resources\n  resourceCache.saveCanonicalResource(await loadStructureDefinition('patient.json'));\n  resourceCache.saveCanonicalResource(await loadStructureDefinition('person.json'));\n  \n  // Step 3: Create or load the StructureMap\n  final parser = await StructureMapParser.create();\n  final mapContent = await File('patient_to_person.map').readAsString();\n  final structureMap = parser.parse(mapContent, 'fhirmap');\n  \n  // Step 4: Create the mapping engine\n  final mapEngine = await FhirMapEngine.create(resourceCache, structureMap);\n  \n  // Step 5: Load source data\n  final patientJson = jsonDecode(await File('sample_patient.json').readAsString());\n  final patient = Patient.fromJson(patientJson);\n  \n  // Step 6: Define custom builder handler (if needed)\n  mapEngine.extendedEmptyFromType = (String type) {\n    // Custom builder creation logic\n    return null;  // Return null for default handling\n  };\n  \n  // Step 7: Perform the transformation\n  final result = await mapEngine.transformFromFhir(\n    patient,\n    structureMap,\n    null,  // No existing target, create new\n  );\n  \n  // Step 8: Use the transformed data\n  final person = result as Person;\n  print('Transformed patient to person: ${person.name?.first.family}');\n  \n  // Step 9: Serialize the result if needed\n  final personJson = person.toJson();\n  await File('transformed_person.json').writeAsString(jsonEncode(personJson));\n}\n\n// Helper function to load structure definitions\nFuture<Resource> loadStructureDefinition(String filename) async {\n  final json = jsonDecode(await File(filename).readAsString());\n  return StructureDefinition.fromJson(json);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-mappings",children:"Testing Mappings"}),"\n",(0,i.jsx)(n.p,{children:"For testing purposes, FHIR-FLI provides a convenience function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Future<FhirBase?> fhirMappingEngine(\n  FhirBaseBuilder source,\n  StructureMap map,\n  ResourceCache cache,\n  FhirBaseBuilder? target, [\n  FhirBaseBuilder? Function(String)? extendedEmptyFromType,\n]) async {\n  final mapEngine = await FhirMapEngine.create(cache, map)\n    ..extendedEmptyFromType = extendedEmptyFromType;\n  final transform = await mapEngine.transformBuilder('', source, map, target);\n  return transform;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This simplifies testing by encapsulating the engine creation and transformation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"test('Patient to Person mapping', () async {\n  final result = await fhirMappingEngine(\n    PatientBuilder.fromJson(sourceData),\n    structureMapPatientToPerson,\n    resourceCache,\n    PersonBuilder.empty(),\n  );\n  \n  expect(result?.toJson(), equals(expectedResult));\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reuse engines"})," for repeated transformations of the same map"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-load resources"})," in the cache for performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Select the appropriate cache level"})," based on your connectivity needs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use builders"})," for complex or incremental transformations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement custom type handlers"})," for domain-specific resource types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test maps thoroughly"})," with representative data"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mapping complex nested structures may require multiple passes"}),"\n",(0,i.jsx)(n.li,{children:"Some complex FHIR mapping features might have performance implications"}),"\n",(0,i.jsx)(n.li,{children:"Resource resolution from online sources introduces latency"}),"\n",(0,i.jsx)(n.li,{children:"Circular references in maps should be handled carefully"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"With a solid understanding of the FHIR Mapping engine, you're ready to implement complex data transformations in your FHIR-FLI applications. Consider exploring the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creating mapping libraries for common transformations"}),"\n",(0,i.jsx)(n.li,{children:"Integrating mapping with your application's data flow"}),"\n",(0,i.jsx)(n.li,{children:"Developing domain-specific extensions to the mapping framework"}),"\n",(0,i.jsx)(n.li,{children:"Contributing improvements back to the FHIR-FLI project"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var i=r(6540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);