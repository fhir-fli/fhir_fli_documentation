"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[556],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var a=r(6540);const t={},i=a.createContext(t);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},8883:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"mapping/fhirmap_parsing","title":"FHIR Map Parser","description":"Understanding the StructureMap Parser","source":"@site/docs/mapping/fhirmap_parsing.md","sourceDirName":"mapping","slug":"/mapping/fhirmap_parsing","permalink":"/fhir_fli_documentation/docs/mapping/fhirmap_parsing","draft":false,"unlisted":false,"editUrl":"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/mapping/fhirmap_parsing.md","tags":[],"version":"current","frontMatter":{"id":"fhirmap_parsing","title":"FHIR Map Parser"},"sidebar":"tutorialSidebar","previous":{"title":"FHIR Mapping Package","permalink":"/fhir_fli_documentation/docs/mapping/fhir_mapping"},"next":{"title":"FHIR Mapping Engine","permalink":"/fhir_fli_documentation/docs/mapping/fhir_mapping_engine"}}');var t=r(4848),i=r(8453);const s={id:"fhirmap_parsing",title:"FHIR Map Parser"},o="FHIR Map to StructureMap Parser in FHIR-FLI",l={},p=[{value:"Understanding the StructureMap Parser",id:"understanding-the-structuremap-parser",level:2},{value:"Creating a StructureMap Parser",id:"creating-a-structuremap-parser",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Parsing Process Details",id:"parsing-process-details",level:2},{value:"Handling Common Scenarios",id:"handling-common-scenarios",level:2},{value:"Parsing From Files",id:"parsing-from-files",level:3},{value:"Comparing Generated Maps to Existing Ones",id:"comparing-generated-maps-to-existing-ones",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Syntax Errors",id:"syntax-errors",level:3},{value:"Validation Errors",id:"validation-errors",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Reusing the Parser",id:"reusing-the-parser",level:3},{value:"Serializing StructureMaps",id:"serializing-structuremaps",level:3},{value:"Example: Complete Parsing Workflow",id:"example-complete-parsing-workflow",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"fhir-map-to-structuremap-parser-in-fhir-fli",children:"FHIR Map to StructureMap Parser in FHIR-FLI"})}),"\n",(0,t.jsx)(n.h2,{id:"understanding-the-structuremap-parser",children:"Understanding the StructureMap Parser"}),"\n",(0,t.jsx)(n.p,{children:"The StructureMap Parser is a crucial component in FHIR mapping that converts the human-readable FHIR mapping language into a formal StructureMap resource that the mapping engine can execute. This conversion process involves parsing the syntax, validating structure, and producing a properly formatted FHIR resource."}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-structuremap-parser",children:"Creating a StructureMap Parser"}),"\n",(0,t.jsx)(n.p,{children:"The parser must be created asynchronously due to internal setup requirements. Here's how to create a parser instance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Create a new StructureMap parser\nfinal parser = await StructureMapParser.create();\n"})}),"\n",(0,t.jsx)(n.p,{children:"This initialization sequence ensures that all the necessary components are properly set up before the parser is used."}),"\n",(0,t.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.p,{children:"Once you have a parser instance, you can use it to parse FHIR mapping language text:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// A string containing FHIR mapping language\nfinal fhirMapText = '''\nmap \"http://example.org/map/PatientToPersonMap\" = PatientToPerson\n\nuses \"http://hl7.org/fhir/StructureDefinition/Patient\" as source\nuses \"http://hl7.org/fhir/StructureDefinition/Person\" as target\n\ngroup PatientToPerson(source src : Patient, target tgt : Person) {\n  src.name -> tgt.name;\n  src.gender -> tgt.gender;\n  src.birthDate -> tgt.birthDate;\n}\n''';\n\n// Parse the mapping language into a StructureMap resource\ntry {\n  final structureMap = parser.parse(fhirMapText, 'fhirmap');\n  print('Successfully parsed StructureMap: ${structureMap.id}');\n} catch (e) {\n  print('Error parsing map: $e');\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"parse"})," method takes two parameters:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The FHIR mapping language text"}),"\n",(0,t.jsx)(n.li,{children:"A format identifier (typically 'fhirmap')"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parsing-process-details",children:"Parsing Process Details"}),"\n",(0,t.jsx)(n.p,{children:"When the parser processes a FHIR map, it goes through several stages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lexical Analysis"})," - Breaks down the text into tokens"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Syntactic Analysis"})," - Creates a parse tree from tokens"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Semantic Analysis"})," - Validates the meaning and relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"StructureMap Construction"})," - Builds the formal FHIR resource"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Throughout this process, the parser handles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"URL and identifier resolution"}),"\n",(0,t.jsx)(n.li,{children:"Group and rule organization"}),"\n",(0,t.jsx)(n.li,{children:"Transform operation mapping"}),"\n",(0,t.jsx)(n.li,{children:"Syntax validation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"handling-common-scenarios",children:"Handling Common Scenarios"}),"\n",(0,t.jsx)(n.h3,{id:"parsing-from-files",children:"Parsing From Files"}),"\n",(0,t.jsx)(n.p,{children:"Often, you'll want to parse mapping files from the file system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"import 'dart:io';\n\nFuture<StructureMap> parseMapFile(String filePath) async {\n  final parser = await StructureMapParser.create();\n  final fileContent = await File(filePath).readAsString();\n  return parser.parse(fileContent, 'fhirmap');\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"comparing-generated-maps-to-existing-ones",children:"Comparing Generated Maps to Existing Ones"}),"\n",(0,t.jsx)(n.p,{children:"When testing or validating your parser, you might want to compare the generated StructureMap to a known good version:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"void compareGeneratedMap(String mapText, String referencePath) async {\n  final parser = await StructureMapParser.create();\n  \n  // Parse the map text\n  final generatedMap = parser.parse(mapText, 'fhirmap');\n  \n  // Load the reference map\n  final referenceMapJson = jsonDecode(await File(referencePath).readAsString());\n  final referenceMap = StructureMap.fromJson(referenceMapJson);\n  \n  // Compare the maps (excluding metadata fields)\n  final generatedJson = generatedMap.toJson()\n    ..remove('text')\n    ..remove('meta');\n  \n  final referenceJson = referenceMap.toJson()\n    ..remove('text')\n    ..remove('meta');\n  \n  final equals = const DeepCollectionEquality().equals(referenceJson, generatedJson);\n  print('Maps are equal: $equals');\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,t.jsx)(n.p,{children:"The parser provides detailed error information when it encounters problems in the mapping language. Common issues include:"}),"\n",(0,t.jsx)(n.h3,{id:"syntax-errors",children:"Syntax Errors"}),"\n",(0,t.jsx)(n.p,{children:"If the map contains syntax errors, the parser will throw an exception with details about the location and nature of the error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"try {\n  final structureMap = parser.parse(invalidMapText, 'fhirmap');\n} catch (e) {\n  print('Syntax error: $e');\n  // Handle the error appropriately\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"validation-errors",children:"Validation Errors"}),"\n",(0,t.jsx)(n.p,{children:"Even with correct syntax, a map might have semantic problems like undefined sources or targets:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"try {\n  final structureMap = parser.parse(semanticallyInvalidMap, 'fhirmap');\n} catch (e) {\n  if (e.toString().contains('undefined source')) {\n    print('Map references undefined source: $e');\n    // Handle the specific error\n  } else {\n    print('Other validation error: $e');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,t.jsx)(n.h3,{id:"reusing-the-parser",children:"Reusing the Parser"}),"\n",(0,t.jsx)(n.p,{children:"The same parser instance can be reused for multiple parsing operations, which is more efficient than creating a new parser each time:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"Future<void> parseMapsInDirectory(String directoryPath) async {\n  final dir = Directory(directoryPath);\n  final parser = await StructureMapParser.create();\n  \n  for (final file in dir.listSync()) {\n    if (file is File && file.path.endsWith('.map')) {\n      try {\n        final content = await File(file.path).readAsString();\n        final map = parser.parse(content, 'fhirmap');\n        print('Successfully parsed ${file.path}');\n        \n        // Do something with the map...\n        \n      } catch (e) {\n        print('Error parsing ${file.path}: $e');\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"serializing-structuremaps",children:"Serializing StructureMaps"}),"\n",(0,t.jsx)(n.p,{children:"After parsing, you might want to serialize the StructureMap to JSON for storage or transmission:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"void saveStructureMap(StructureMap map, String outputPath) {\n  final json = map.toJson();\n  final prettyJson = JsonEncoder.withIndent('  ').convert(json);\n  File(outputPath).writeAsStringSync(prettyJson);\n  print('Saved StructureMap to $outputPath');\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"example-complete-parsing-workflow",children:"Example: Complete Parsing Workflow"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example that demonstrates parsing a FHIR map from a file, validating it, and saving the result:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"import 'dart:convert';\nimport 'dart:io';\n\nimport 'package:collection/collection.dart';\nimport 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_mapping/fhir_r4_mapping.dart';\n\nFuture<void> processMapFile(String inputPath, String outputPath) async {\n  try {\n    // Create the parser\n    final parser = await StructureMapParser.create();\n    \n    // Read and parse the map file\n    final mapContent = await File(inputPath).readAsString();\n    final structureMap = parser.parse(mapContent, 'fhirmap');\n    \n    // Validate by comparing with a reference if available\n    final referencePath = inputPath.replaceAll('.map', '.json');\n    if (await File(referencePath).exists()) {\n      final referenceJson = jsonDecode(await File(referencePath).readAsString());\n      final referenceMap = StructureMap.fromJson(referenceJson);\n      \n      // Compare maps (excluding metadata)\n      final generatedJson = structureMap.toJson()\n        ..remove('text')\n        ..remove('meta');\n      \n      final referenceJson2 = referenceMap.toJson()\n        ..remove('text')\n        ..remove('meta');\n      \n      final equals = const DeepCollectionEquality().equals(referenceJson2, generatedJson);\n      print('Validation result: maps are ${equals ? \"equal\" : \"different\"}');\n    }\n    \n    // Save the parsed map to the output path\n    final prettyJson = JsonEncoder.withIndent('  ').convert(structureMap.toJson());\n    await File(outputPath).writeAsString(prettyJson);\n    print('Successfully processed and saved map to $outputPath');\n    \n  } catch (e, s) {\n    print('Error processing map file: $e');\n    print('Stack trace: $s');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"When working with the StructureMap Parser, follow these best practices:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reuse the parser instance"})," for multiple parsing operations to improve performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle exceptions"})," properly to provide meaningful feedback about parsing errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate maps"})," against reference implementations when available"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Make parser creation asynchronous"})," as shown in the examples"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Store both map text and StructureMap resources"})," for easier maintenance"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.p,{children:["Now that you understand how to parse FHIR mapping language into StructureMap resources, the next step is to learn how to use the ",(0,t.jsx)(n.a,{href:"/fhir_fli_documentation/docs/mapping/fhir_mapping_engine",children:"FHIR Mapping Engine"})," to execute these maps and transform data."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);