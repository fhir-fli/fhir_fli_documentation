"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[336],{2205:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var i=a(4848),r=a(8453);const t={id:"fhir_r4_path",title:"FHIRPath Package"},s="FHIRPath Engine",o={id:"fhir_r4_path",title:"FHIRPath Package",description:"The fhirr4path library provides a Dart implementation of the FHIRPath specification, allowing you to query and manipulate FHIR resources using standardized expressions. This library follows the official HL7 FHIRPath specification and integrates seamlessly with the fhir_r4 package.",source:"@site/docs/fhir_r4_path.md",sourceDirName:".",slug:"/fhir_r4_path",permalink:"/fhir_fli_documentation/docs/fhir_r4_path",draft:!1,unlisted:!1,editUrl:"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/fhir_r4_path.md",tags:[],version:"current",frontMatter:{id:"fhir_r4_path",title:"FHIRPath Package"},sidebar:"tutorialSidebar",previous:{title:"Bulk Data",permalink:"/fhir_fli_documentation/docs/fhir_r4_bulk"},next:{title:"Utility Package",permalink:"/fhir_fli_documentation/docs/fhir_r4_utils"}},c={},l=[{value:"Installation",id:"installation",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"1. Simple Approach: walkFhirPath (async)",id:"1-simple-approach-walkfhirpath-async",level:3},{value:"2. Engine Approach: FHIRPathEngine (preferred for performance)",id:"2-engine-approach-fhirpathengine-preferred-for-performance",level:3},{value:"Creating the Engine",id:"creating-the-engine",level:4},{value:"Evaluating Expressions",id:"evaluating-expressions",level:4},{value:"Common FHIRPath Expressions",id:"common-fhirpath-expressions",level:2},{value:"Basic Navigation",id:"basic-navigation",level:3},{value:"Functions",id:"functions",level:3},{value:"Operators",id:"operators",level:3},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Resource Cache",id:"resource-cache",level:3},{value:"Canonical Resource Manager",id:"canonical-resource-manager",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Reuse Parsed Expressions",id:"reuse-parsed-expressions",level:3},{value:"Use a Dedicated Engine",id:"use-a-dedicated-engine",level:3},{value:"Leverage the Resource Cache",id:"leverage-the-resource-cache",level:3},{value:"Integration with FHIR Mapping",id:"integration-with-fhir-mapping",level:2},{value:"FHIRPath Specification Reference",id:"fhirpath-specification-reference",level:2},{value:"Appendix: Legacy Access Methods",id:"appendix-legacy-access-methods",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"fhirpath-engine",children:"FHIRPath Engine"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"fhir_r4_path"})," library provides a Dart implementation of the ",(0,i.jsx)(n.a,{href:"https://hl7.org/fhirpath/",children:"FHIRPath"})," specification, allowing you to query and manipulate FHIR resources using standardized expressions. This library follows the official HL7 FHIRPath specification and integrates seamlessly with the ",(0,i.jsx)(n.code,{children:"fhir_r4"})," package."]}),"\n",(0,i.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"dependencies:\n  fhir_r4_path: ^0.3.0\n  fhir_r4: ^0.3.0\n"})}),"\n",(0,i.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(n.p,{children:"There are two main approaches to using the FHIRPath engine:"}),"\n",(0,i.jsx)(n.h3,{id:"1-simple-approach-walkfhirpath-async",children:"1. Simple Approach: walkFhirPath (async)"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"walkFhirPath"})," function provides a straightforward way to evaluate a FHIRPath expression against a FHIR resource without having to manage an engine instance yourself:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_path/fhir_r4_path.dart';\n\nvoid main() async {\n  // Create a patient resource\n  final patient = Patient(\n    name: [\n      HumanName(\n        family: 'Doe'.toFhirString,\n        given: ['John'.toFhirString],\n        use: HumanNameUse.official,\n      ),\n    ],\n  );\n\n  // Evaluate a FHIRPath expression\n  final result = await walkFhirPath(\n    context: patient,\n    pathExpression: \"Patient.name.where(use = 'official').family\",\n  );\n\n  // The result will be a List<FhirBase>\n  print(result.map((e) => e.toString()).join(', ')); // Outputs: Doe\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Parameters for ",(0,i.jsx)(n.code,{children:"walkFhirPath"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"context"}),": The FHIR resource to query (required)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pathExpression"}),": The FHIRPath expression to evaluate (required)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"resource"}),": The resource that contains the original node (defaults to context if null)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rootResource"}),": The container resource (if applicable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"environment"}),": A map of environment variables (keys must start with %)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-engine-approach-fhirpathengine-preferred-for-performance",children:"2. Engine Approach: FHIRPathEngine (preferred for performance)"}),"\n",(0,i.jsxs)(n.p,{children:["When you have multiple FHIRPath expressions or you need to evaluate many resources in a loop, the recommended approach is to create a reusable ",(0,i.jsx)(n.code,{children:"FHIRPathEngine"})," instance. This is more efficient because you only parse expressions once and can share internal structures."]}),"\n",(0,i.jsx)(n.h4,{id:"creating-the-engine",children:"Creating the Engine"}),"\n",(0,i.jsxs)(n.p,{children:["Because the engine initialization is asynchronous, you'll use the static ",(0,i.jsx)(n.code,{children:"create(...)"})," factory method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_path/fhir_r4_path.dart';\n\nvoid main() async {\n  // Create the FHIRPath engine (async)\n  final fhirPathEngine = await FHIRPathEngine.create(WorkerContext());\n\n  // Parse the expression once (can be reused)\n  final node = fhirPathEngine.parse(\"Patient.name.where(use = 'official').family\");\n\n  // Create some resources to test against\n  final patient1 = Patient(\n    name: [\n      HumanName(\n        family: 'Smith'.toFhirString,\n        given: ['Jane'.toFhirString],\n        use: HumanNameUse.official,\n      ),\n    ],\n  );\n\n  final patient2 = Patient(\n    name: [\n      HumanName(\n        family: 'Brown'.toFhirString,\n        given: ['Charlie'.toFhirString],\n        use: HumanNameUse.official,\n      ),\n    ],\n  );\n\n  // Evaluate against different patients\n  final result1 = await fhirPathEngine.evaluate(patient1, node);\n  final result2 = await fhirPathEngine.evaluate(patient2, node);\n\n  print(result1); // [Smith]\n  print(result2); // [Brown]\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"evaluating-expressions",children:"Evaluating Expressions"}),"\n",(0,i.jsxs)(n.p,{children:["Once you have the ",(0,i.jsx)(n.code,{children:"FHIRPathEngine"})," instance:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parse(String expression)"}),": Parses and returns an ",(0,i.jsx)(n.code,{children:"ExpressionNode"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"evaluate(FhirBase? base, ExpressionNode node)"}),": Evaluates the parsed expression against the base resource."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"evaluateWithContext(...)"}),": Allows you to provide additional context/resources or environment variables."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final result3 = await fhirPathEngine.evaluateWithContext(\n  null,      // appContext (any object, e.g., a custom context or null)\n  patient1,  // focusResource\n  null,      // rootResource\n  patient1,  // base (the immediate context for evaluation)\n  node,\n  environment: {\n    '%var1': [42.toFhirInteger],\n    '%var2': ['test'.toFhirString],\n  },\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-fhirpath-expressions",children:"Common FHIRPath Expressions"}),"\n",(0,i.jsx)(n.p,{children:"Here are some examples of common FHIRPath expressions:"}),"\n",(0,i.jsx)(n.h3,{id:"basic-navigation",children:"Basic Navigation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fhirpath",children:"// Access a field\nPatient.active\n\n// Access an array element\nPatient.name[0]\n\n// Access a field in an array\nPatient.name.family\n\n// Access a field with a specific value\nPatient.name.where(use = 'official')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fhirpath",children:"// Count elements\nPatient.name.count()\n\n// Check if telecom exists\nPatient.telecom.exists()\n\n// Filter with conditions\nPatient.telecom.where(system = 'phone')\n\n// First/last elements\nPatient.name.first()\nPatient.name.last()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operators",children:"Operators"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fhirpath",children:"// Equality\nPatient.gender = 'male'\n\n// Comparison\nPatient.name.count() > 1\n\n// Logical operators\nPatient.active = true and Patient.deceased = false\n"})}),"\n",(0,i.jsx)(n.h3,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,i.jsxs)(n.p,{children:["FHIRPath supports environment variables, which must be prefixed with ",(0,i.jsx)(n.code,{children:"%"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final environment = {\n  '%pi': [3.14159.toFhirDecimal],\n  '%today': [FhirDateTime('2023-01-01')],\n};\n\nfinal result = await walkFhirPath(\n  context: patient,\n  pathExpression: \"Patient.birthDate < %today\",\n  environment: environment,\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(n.h3,{id:"resource-cache",children:"Resource Cache"}),"\n",(0,i.jsxs)(n.p,{children:["For advanced scenarios, the library provides a ",(0,i.jsx)(n.code,{children:"ResourceCache"})," abstract class to cache canonical resources (like CodeSystem, ValueSet, StructureDefinition), potentially saving time on repeated lookups:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"abstract class ResourceCache {\n  Future<T?> getCanonicalResource<T extends CanonicalResource>(\n    String url, [String? version]\n  );\n  \n  Future<void> saveCanonicalResource(CanonicalResource resource);\n  \n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"canonical-resource-manager",children:"Canonical Resource Manager"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"CanonicalResourceManager"})," extends ",(0,i.jsx)(n.code,{children:"ResourceCache"})," to provide version-aware storage and retrieval of resources:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_path/fhir_r4_path.dart';\n\n// Create a manager\nfinal manager = CanonicalResourceManager();\n\n// Store a canonical resource\nfinal valueSet = ValueSet(\n  url: 'http://example.org/fhir/ValueSet/my-codes'.toFhirUri,\n  version: '1.0.0'.toFhirString,\n  name: 'MyCodes'.toFhirString,\n);\nmanager.see(valueSet);\n\n// Retrieve by URL\nfinal retrieved = await manager.getCanonicalResource<ValueSet>(\n  'http://example.org/fhir/ValueSet/my-codes'\n);\n\n// Retrieve by URL and version\nfinal specificVersion = await manager.getCanonicalResource<ValueSet>(\n  'http://example.org/fhir/ValueSet/my-codes',\n  '1.0.0'\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Key features of ",(0,i.jsx)(n.code,{children:"CanonicalResourceManager"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Version-aware storage and retrieval"}),"\n",(0,i.jsx)(n.li,{children:"Compatibility with semantic versioning"}),"\n",(0,i.jsx)(n.li,{children:"Optional lazy loading through proxies"}),"\n",(0,i.jsx)(n.li,{children:"Integration with HTTP clients for remote resource fetching"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"The FHIRPath engine throws specific exceptions that give detailed information about evaluation issues:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"try {\n  final result = await walkFhirPath(\n    context: patient,\n    pathExpression: \"Patient.invalid.expression\",\n  );\n} on PathEngineException catch (e) {\n  print('Expression error: ${e.message}');\n  print('Expression: ${e.expression}');\n} on PathEngineError catch (e) {\n  print('Engine error: ${e.message}');\n  print('Expression: ${e.expression}');\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:"For optimal performance in large-scale or batch operations:"}),"\n",(0,i.jsx)(n.h3,{id:"reuse-parsed-expressions",children:"Reuse Parsed Expressions"}),"\n",(0,i.jsxs)(n.p,{children:["Parse the expression once with ",(0,i.jsx)(n.code,{children:"fhirPathEngine.parse()"})," and then evaluate repeatedly on different resources."]}),"\n",(0,i.jsx)(n.h3,{id:"use-a-dedicated-engine",children:"Use a Dedicated Engine"}),"\n",(0,i.jsxs)(n.p,{children:["Instead of ",(0,i.jsx)(n.code,{children:"walkFhirPath()"}),", create and reuse a single ",(0,i.jsx)(n.code,{children:"FHIRPathEngine"})," instance (via the async ",(0,i.jsx)(n.code,{children:"create(...)"})," method)."]}),"\n",(0,i.jsx)(n.h3,{id:"leverage-the-resource-cache",children:"Leverage the Resource Cache"}),"\n",(0,i.jsxs)(n.p,{children:["If your workflow requires repeated lookups of canonical resources, use ",(0,i.jsx)(n.code,{children:"CanonicalResourceManager"})," to avoid redundant fetching or parsing."]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-fhir-mapping",children:"Integration with FHIR Mapping"}),"\n",(0,i.jsxs)(n.p,{children:["The FHIRPath engine is also used by the FHIR Mapping engine (",(0,i.jsx)(n.code,{children:"fhir_r4_mapping"}),"), which implements the FHIR Mapping Language for transforming FHIR resources or converting between FHIR and other data formats."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\nimport 'package:fhir_r4_mapping/fhir_r4_mapping.dart';\n\n// Transform a resource using a StructureMap\nfinal transformedResource = await fhirMappingEngine(\n  source,\n  structureMap,\n  resourceCache,\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fhirpath-specification-reference",children:"FHIRPath Specification Reference"}),"\n",(0,i.jsxs)(n.p,{children:["For a complete reference of the FHIRPath language, see the ",(0,i.jsx)(n.a,{href:"https://hl7.org/fhirpath/",children:"official specification"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The implementation supports:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Basic types (Boolean, String, Integer, Decimal, DateTime)"}),"\n",(0,i.jsx)(n.li,{children:"Path selection and navigation"}),"\n",(0,i.jsx)(n.li,{children:"Basic operators (equality, comparison, logical)"}),"\n",(0,i.jsx)(n.li,{children:"Functions with and without arguments"}),"\n",(0,i.jsx)(n.li,{children:"Environment variables"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Currently not fully supported:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Trace functionality"}),"\n",(0,i.jsx)(n.li,{children:"Complete reflection capabilities"}),"\n",(0,i.jsx)(n.li,{children:"System namespaces"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-legacy-access-methods",children:"Appendix: Legacy Access Methods"}),"\n",(0,i.jsxs)(n.p,{children:["While the new ",(0,i.jsx)(n.code,{children:"FHIRPathEngine.create(...)"}),' approach is recommended for most cases, the package includes a "legacy" or "simple" convenience method, ',(0,i.jsx)(n.code,{children:"walkFhirPath()"}),". This is often sufficient for quick, single-use evaluations:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final result = await walkFhirPath(\n  context: patient,\n  pathExpression: '`Patient`.name.`given`[0]',\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Under the hood, ",(0,i.jsx)(n.code,{children:"walkFhirPath"})," uses the same engine but without exposing the details. This makes it easier for one-off expressions but less optimal for repeated operations."]}),"\n",(0,i.jsx)(n.p,{children:"Happy coding with FHIRPath in Dart!"})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(6540);const r={},t=i.createContext(r);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);