"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[855],{2122:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core/migration","title":"Migration","description":"Introduction","source":"@site/docs/core/migration.md","sourceDirName":"core","slug":"/core/migration","permalink":"/fhir_fli_documentation/docs/core/migration","draft":false,"unlisted":false,"editUrl":"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/core/migration.md","tags":[],"version":"current","frontMatter":{"id":"migration","title":"Migration"},"sidebar":"tutorialSidebar","previous":{"title":"Enums","permalink":"/fhir_fli_documentation/docs/core/enums"},"next":{"title":"At Rest Package","permalink":"/fhir_fli_documentation/docs/at_rest/fhir_r4_at_rest"}}');var s=i(4848),a=i(8453);const r={id:"migration",title:"Migration"},l="Migration Guide: From fhir (old) to fhir_r4 (new)",d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Package Installation",id:"package-installation",level:2},{value:"Old Package",id:"old-package",level:3},{value:"New Package",id:"new-package",level:3},{value:"Import Changes",id:"import-changes",level:2},{value:"Old Package",id:"old-package-1",level:3},{value:"New Package",id:"new-package-1",level:3},{value:"Primitive Types - The Biggest Change",id:"primitive-types---the-biggest-change",level:2},{value:"The Old Way",id:"the-old-way",level:3},{value:"The New Way",id:"the-new-way",level:3},{value:"Key Differences",id:"key-differences",level:3},{value:"Migration Actions",id:"migration-actions",level:3},{value:"Search and Replace Strategy",id:"search-and-replace-strategy",level:3},{value:"Resource Construction",id:"resource-construction",level:2},{value:"Old Package",id:"old-package-2",level:3},{value:"New Package",id:"new-package-2",level:3},{value:"Enums and Code Values",id:"enums-and-code-values",level:2},{value:"Old Package Approach",id:"old-package-approach",level:3},{value:"New Package Approach",id:"new-package-approach",level:3},{value:"Migration Steps for Enums",id:"migration-steps-for-enums",level:3},{value:"Important: Custom Enum Values",id:"important-custom-enum-values",level:3},{value:"Polymorphic Types",id:"polymorphic-types",level:2},{value:"Old Package",id:"old-package-3",level:3},{value:"New Package",id:"new-package-3",level:3},{value:"Naming Convention Change",id:"naming-convention-change",level:3},{value:"Migration for Polymorphic Fields",id:"migration-for-polymorphic-fields",level:3},{value:"Serialization and Deserialization",id:"serialization-and-deserialization",level:2},{value:"JSON Serialization",id:"json-serialization",level:3},{value:"YAML Support (New!)",id:"yaml-support-new",level:3},{value:"Migration Steps",id:"migration-steps",level:3},{value:"Utility Methods",id:"utility-methods",level:2},{value:"New Utility Methods",id:"new-utility-methods",level:3},{value:"1. <code>listChildrenNames()</code>",id:"1-listchildrennames",level:4},{value:"2. <code>getChildrenByName(String name)</code>",id:"2-getchildrenbynamestring-name",level:4},{value:"3. <code>getChildByName(String name)</code>",id:"3-getchildbynamestring-name",level:4},{value:"4. <code>copyWith()</code>",id:"4-copywith",level:4},{value:"5. <code>equalsDeep()</code>",id:"5-equalsdeep",level:4},{value:"Migration Benefit",id:"migration-benefit",level:3},{value:"Common Migration Patterns",id:"common-migration-patterns",level:2},{value:"Pattern 1: Accessing Nested Primitive Values",id:"pattern-1-accessing-nested-primitive-values",level:3},{value:"Pattern 2: Creating Resources with Primitives",id:"pattern-2-creating-resources-with-primitives",level:3},{value:"Pattern 3: Checking for Null Values",id:"pattern-3-checking-for-null-values",level:3},{value:"Pattern 4: Working with Lists",id:"pattern-4-working-with-lists",level:3},{value:"Pattern 5: Polymorphic Extensions",id:"pattern-5-polymorphic-extensions",level:3},{value:"Breaking Changes Checklist",id:"breaking-changes-checklist",level:2},{value:"1. Imports",id:"1-imports",level:3},{value:"2. Primitive Types",id:"2-primitive-types",level:3},{value:"3. Enums",id:"3-enums",level:3},{value:"4. Polymorphic Fields",id:"4-polymorphic-fields",level:3},{value:"5. Serialization",id:"5-serialization",level:3},{value:"6. Testing",id:"6-testing",level:3},{value:"7. Consider Adopting New Features",id:"7-consider-adopting-new-features",level:3},{value:"Step-by-Step Migration Process",id:"step-by-step-migration-process",level:2},{value:"Phase 1: Setup (30 minutes)",id:"phase-1-setup-30-minutes",level:3},{value:"Phase 2: Fix Compilation Errors (2-4 hours depending on codebase size)",id:"phase-2-fix-compilation-errors-2-4-hours-depending-on-codebase-size",level:3},{value:"Phase 3: Testing (1-2 hours)",id:"phase-3-testing-1-2-hours",level:3},{value:"Phase 4: Optimization (optional, 1-2 hours)",id:"phase-4-optimization-optional-1-2-hours",level:3},{value:"Quick Reference Table",id:"quick-reference-table",level:2},{value:"Troubleshooting Common Errors",id:"troubleshooting-common-errors",level:2},{value:"Error: &quot;The getter &#39;value&#39; isn&#39;t defined&quot;",id:"error-the-getter-value-isnt-defined",level:3},{value:"Error: &quot;The argument type &#39;String&#39; can&#39;t be assigned to the parameter type &#39;AppointmentStatus&#39;&quot;",id:"error-the-argument-type-string-cant-be-assigned-to-the-parameter-type-appointmentstatus",level:3},{value:"Error: &quot;The getter &#39;product&#39; isn&#39;t defined&quot;",id:"error-the-getter-product-isnt-defined",level:3},{value:"Error: &quot;The operator &#39;==&#39; isn&#39;t defined for the type&quot;",id:"error-the-operator--isnt-defined-for-the-type",level:3},{value:"Example: Complete Migration",id:"example-complete-migration",level:2},{value:"Before (Old Package)",id:"before-old-package",level:3},{value:"After (New Package)",id:"after-new-package",level:3},{value:"Getting Help",id:"getting-help",level:2},{value:"Summary",id:"summary",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"migration-guide-from-fhir-old-to-fhir_r4-new",children:"Migration Guide: From fhir (old) to fhir_r4 (new)"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["This guide will help you migrate from the older ",(0,s.jsx)(n.code,{children:"fhir"})," package to the newer, more robust ",(0,s.jsx)(n.code,{children:"fhir_r4"})," package. While the syntax is mostly similar since both packages generate code from the same FHIR specification, there are important structural differences and improvements that require attention during migration."]}),"\n",(0,s.jsx)(n.p,{children:"The good news: Most of your resource construction code will work with minimal changes. The main differences are in how primitive types are handled, how polymorphic fields work, and some improved helper methods."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#package-installation",children:"Package Installation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#import-changes",children:"Import Changes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#primitive-types---the-biggest-change",children:"Primitive Types - The Biggest Change"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#resource-construction",children:"Resource Construction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#enums-and-code-values",children:"Enums and Code Values"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#polymorphic-types",children:"Polymorphic Types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#serialization-and-deserialization",children:"Serialization and Deserialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#utility-methods",children:"Utility Methods"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#common-migration-patterns",children:"Common Migration Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#breaking-changes-checklist",children:"Breaking Changes Checklist"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"package-installation",children:"Package Installation"}),"\n",(0,s.jsx)(n.h3,{id:"old-package",children:"Old Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"dependencies:\n  fhir: ^0.x.x\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-package",children:"New Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"dependencies:\n  fhir_r4: ^0.4.2\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Action Required:"})," Update your ",(0,s.jsx)(n.code,{children:"pubspec.yaml"})," and run ",(0,s.jsx)(n.code,{children:"flutter pub get"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"import-changes",children:"Import Changes"}),"\n",(0,s.jsx)(n.h3,{id:"old-package-1",children:"Old Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir/fhir.dart';\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-package-1",children:"New Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Action Required:"})," Find and replace all imports throughout your codebase."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"primitive-types---the-biggest-change",children:"Primitive Types - The Biggest Change"}),"\n",(0,s.jsx)(n.p,{children:"This is where you'll encounter the most errors during migration. The old package handled primitive types differently than the new one."}),"\n",(0,s.jsx)(n.h3,{id:"the-old-way",children:"The Old Way"}),"\n",(0,s.jsx)(n.p,{children:"In the old package, primitive types were simpler wrapper classes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old package\nclass FhirId {\n  final String? _value;\n  final bool _isValid;\n  \n  String? get value => _value;\n  bool get isValid => _isValid;\n}\n\n// Usage\nfinal id = FhirId('patient-123');\nfinal idValue = id.value;  // Just the string\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-new-way",children:"The New Way"}),"\n",(0,s.jsxs)(n.p,{children:["In the new package, ALL primitive types extend ",(0,s.jsx)(n.code,{children:"PrimitiveType"})," and have a more structured approach:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// New package\nclass FhirId extends PrimitiveType {\n  final String? valueString;  // The actual value\n  final Element? element;     // Metadata/extensions\n  \n  // Note: No more .value getter in new package!\n}\n\n// Usage\nfinal id = FhirId('patient-123');\nfinal idValue = id.valueString;  // Note: .valueString, not .value\n"})}),"\n",(0,s.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Old Package"}),(0,s.jsx)(n.th,{children:"New Package"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueString"})}),(0,s.jsx)(n.td,{children:"For accessing the string value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"No element support"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".element"})}),(0,s.jsx)(n.td,{children:"Can now carry extensions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simple constructors"}),(0,s.jsx)(n.td,{children:"Rich constructors"}),(0,s.jsx)(n.td,{children:"Support for element parameter"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Limited metadata"}),(0,s.jsx)(n.td,{children:"Full FHIR support"}),(0,s.jsx)(n.td,{children:"Proper extension handling"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"migration-actions",children:"Migration Actions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["1. Find and Replace ",(0,s.jsx)(n.code,{children:".value"})," with ",(0,s.jsx)(n.code,{children:".valueString"})]})}),"\n",(0,s.jsx)(n.p,{children:"This is the most common change you'll need to make:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nif (patient.id?.value == '123') { ... }\nfinal name = patient.name?.first.given?.first.value;\n\n// New\nif (patient.id?.valueString == '123') { ... }\nfinal name = patient.name?.first.given?.first.valueString;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Update Primitive Type Constructors"})}),"\n",(0,s.jsx)(n.p,{children:"The new package has more ways to create primitives:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nfinal str = FhirString('Hello');\nfinal date = FhirDate('2024-01-01');\nfinal id = FhirId('patient-123');\n\n// New - Still works!\nfinal str = FhirString('Hello');\nfinal date = FhirDate('2024-01-01');\nfinal id = FhirId('patient-123');\n\n// New - Extension methods (recommended)\nfinal str = 'Hello'.toFhirString;\nfinal date = '2024-01-01'.toFhirDate;\n\n// New - With element/extensions\nfinal str = FhirString(\n  'Hello',\n  element: Element(\n    extension_: [\n      FhirExtension(\n        url: FhirUri('http://example.org/ext'),\n        valueString: FhirString('metadata'),\n      ),\n    ],\n  ),\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Specific Primitive Type Changes"})}),"\n",(0,s.jsx)(n.p,{children:"Different primitive types have different getter names in the new package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Boolean\n// Old: myBool.value  (bool?)\n// New: myBool.valueBoolean  (bool?)\n\n// Integer  \n// Old: myInt.value  (int?)\n// New: myInt.valueInteger  (int?)\n\n// Decimal\n// Old: myDecimal.value  (double?)\n// New: myDecimal.valueDecimal  (double?)\n\n// DateTime\n// Old: myDateTime.value  (DateTime?)\n// New: myDateTime.valueDateTime  (DateTime?)\n\n// Date\n// Old: myDate.value  (DateTime?)\n// New: myDate.valueDateTime  (DateTime?)\n\n// String types (FhirString, FhirMarkdown, etc.)\n// Old: myString.value  (String?)\n// New: myString.valueString  (String?)\n\n// Uri types (FhirUri, FhirUrl, FhirCanonical, FhirOid, FhirUuid)\n// Old: myUri.value  (String?)\n// New: myUri.valueString  (String?) OR myUri.valueUri  (Uri?)\n\n// Id\n// Old: myId.value  (String?)\n// New: myId.valueString  (String?)\n\n// Code\n// Old: myCode.value  (String?)\n// New: myCode.valueString  (String?)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"search-and-replace-strategy",children:"Search and Replace Strategy"}),"\n",(0,s.jsx)(n.p,{children:"Here's a systematic approach:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.strong,{children:["Global search for ",(0,s.jsx)(n.code,{children:".value"})," in your codebase"]})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"For each occurrence, determine the type"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If it's a primitive FHIR type, replace with the appropriate getter"}),"\n",(0,s.jsx)(n.li,{children:"If it's not a FHIR type, leave it alone"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use your IDE's type inference"})," to help identify what needs changing"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip:"})," You can do a regex search for common patterns:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-regex",children:"\\.value(?!\\w)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will find ",(0,s.jsx)(n.code,{children:".value"})," but not ",(0,s.jsx)(n.code,{children:".valueString"}),", ",(0,s.jsx)(n.code,{children:".valueBoolean"}),", etc."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"resource-construction",children:"Resource Construction"}),"\n",(0,s.jsx)(n.p,{children:"Resource construction is largely unchanged, but with improved primitive type handling:"}),"\n",(0,s.jsx)(n.h3,{id:"old-package-2",children:"Old Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final patient = Patient(\n  id: FhirId('123'),\n  name: [\n    HumanName(\n      family: FhirString('Doe'),\n      given: [FhirString('John')],\n    ),\n  ],\n  birthDate: FhirDate('1990-01-01'),\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-package-2",children:"New Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Option 1: Same as old (still works!)\nfinal patient = Patient(\n  id: FhirId('123'),\n  name: [\n    HumanName(\n      family: FhirString('Doe'),\n      given: [FhirString('John')],\n    ),\n  ],\n  birthDate: FhirDate('1990-01-01'),\n);\n\n// Option 2: Using extension methods (recommended)\nfinal patient = Patient(\n  id: '123'.toFhirId,\n  name: [\n    HumanName(\n      family: 'Doe'.toFhirString,\n      given: ['John'.toFhirString],\n    ),\n  ],\n  birthDate: '1990-01-01'.toFhirDate,\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Migration Impact:"})," Minimal. Most construction code works as-is, but you should consider adopting extension methods for cleaner code."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"enums-and-code-values",children:"Enums and Code Values"}),"\n",(0,s.jsx)(n.p,{children:"This is another significant change. The old package used simpler enum handling, while the new package has a sophisticated dual-enum system."}),"\n",(0,s.jsx)(n.h3,{id:"old-package-approach",children:"Old Package Approach"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old package likely used string values or simple enums\nfinal status = 'active';  // or\nfinal status = AppointmentStatus.active;\n\n// In resources\nfinal appointment = Appointment(\n  status: status,\n  // ...\n);\n\n// Checking values\nif (appointment.status == 'active') { ... }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-package-approach",children:"New Package Approach"}),"\n",(0,s.jsxs)(n.p,{children:["The new package uses ",(0,s.jsx)(n.code,{children:"FhirCodeEnum"})," classes that wrap FHIR codes AND provides native Dart enums:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// New package - Using the FhirCodeEnum class\nfinal status = AppointmentStatus.booked;  // FhirCodeEnum\n\n// In resources\nfinal appointment = Appointment(\n  status: AppointmentStatus.booked,\n  // ...\n);\n\n// Checking values - Multiple ways:\n\n// 1. Direct equality\nif (appointment.status == AppointmentStatus.booked) { ... }\n\n// 2. Using the native enum (recommended for switch statements)\nswitch (appointment.status?.valueEnum) {\n  case AppointmentStatusEnum.booked:\n    // Handle booked\n    break;\n  case AppointmentStatusEnum.cancelled:\n    // Handle cancelled\n    break;\n  case AppointmentStatusEnum.pending:\n    // Handle pending\n    break;\n  case null:\n    // Handle null or custom values\n    break;\n}\n\n// 3. String comparison\nif (appointment.status?.valueString == 'booked') { ... }\n\n// Accessing metadata\nfinal system = AppointmentStatus.booked.system;  // FhirUri\nfinal display = AppointmentStatus.booked.display;  // FhirString\n"})}),"\n",(0,s.jsx)(n.h3,{id:"migration-steps-for-enums",children:"Migration Steps for Enums"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replace string literals"})," with enum values:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nfinal status = 'booked';\n\n// New\nfinal status = AppointmentStatus.booked;\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update equality checks"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nif (status == 'booked') { ... }\n\n// New - Recommended\nif (status == AppointmentStatus.booked) { ... }\n// OR\nif (status?.valueEnum == AppointmentStatusEnum.booked) { ... }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Convert switch statements"})," to use the new enum:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nswitch (status) {\n  case 'booked':\n    // ...\n  case 'cancelled':\n    // ...\n}\n\n// New - Much better with native enums!\nswitch (status?.valueEnum) {\n  case AppointmentStatusEnum.booked:\n    // ...\n  case AppointmentStatusEnum.cancelled:\n    // ...\n  case null:\n    // Handle custom or null values\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"important-custom-enum-values",children:"Important: Custom Enum Values"}),"\n",(0,s.jsx)(n.p,{children:"The new package supports custom/extended enum values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Create a custom status not in the standard set\nfinal customStatus = AppointmentStatus('custom-value');\n\n// Note: customStatus.valueEnum will be null\n// But customStatus.valueString will be 'custom-value'\n\n// Handling in code:\nswitch (appointment.status?.valueEnum) {\n  case AppointmentStatusEnum.booked:\n    // Standard value\n    break;\n  case null:\n    // Could be custom or null\n    if (appointment.status?.valueString == 'custom-value') {\n      // Handle custom\n    }\n    break;\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"polymorphic-types",children:"Polymorphic Types"}),"\n",(0,s.jsx)(n.p,{children:"Polymorphic fields (those that can contain multiple types) are handled differently."}),"\n",(0,s.jsx)(n.h3,{id:"old-package-3",children:"Old Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old package - Less type-safe approach\n// Likely used dynamic or Object types\nfinal extension = FhirExtension(\n  url: FhirUri('http://example.org/ext'),\n  value: FhirString('some value'),  // Could be various types\n);\n\n// Accessing required casting\nfinal value = extension.value;\nif (value is FhirString) {\n  final stringValue = value.value;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-package-3",children:"New Package"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// New package - Type-safe with abstract classes\nfinal extension = FhirExtension(\n  url: FhirUri('http://example.org/ext'),\n  valueX: FhirString('some value'),  // Note: valueX, not value\n);\n\n// Accessing with type-specific getters\nfinal stringValue = extension.valueString;  // FhirString?\nfinal boolValue = extension.valueBoolean;   // FhirBoolean?\nfinal codeValue = extension.valueCode;       // FhirCode?\n\n// Using the generic accessor\nif (extension.valueX is FhirString) {\n  final str = extension.valueX as FhirString;\n  // Use str\n}\n\n// Or using the helper method\nfinal str = extension.valueX?.isAs<FhirString>();\nif (str != null) {\n  // Use str\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"naming-convention-change",children:"Naming Convention Change"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Old:"})," Polymorphic fields might have been named ",(0,s.jsx)(n.code,{children:"value"}),", ",(0,s.jsx)(n.code,{children:"product"}),", ",(0,s.jsx)(n.code,{children:"subject"}),", etc."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"New:"})," Polymorphic fields are named with an ",(0,s.jsx)(n.code,{children:"X"})," suffix: ",(0,s.jsx)(n.code,{children:"valueX"}),", ",(0,s.jsx)(n.code,{children:"productX"}),", ",(0,s.jsx)(n.code,{children:"subjectX"}),", ",(0,s.jsx)(n.code,{children:"scheduledX"}),", etc."]}),"\n",(0,s.jsx)(n.h3,{id:"migration-for-polymorphic-fields",children:"Migration for Polymorphic Fields"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Identify polymorphic fields"})," in your code (usually documented in FHIR spec as ",(0,s.jsx)(n.code,{children:"[x]"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rename the field access"})," to add ",(0,s.jsx)(n.code,{children:"X"})," suffix:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nfinal value = extension.value;\nfinal product = carePlan.product;\n\n// New\nfinal value = extension.valueX;\nfinal product = carePlan.productX;\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use type-specific getters"})," instead of casting:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nif (extension.value is FhirString) {\n  final str = (extension.value as FhirString).value;\n}\n\n// New - Much cleaner!\nif (extension.valueString != null) {\n  final str = extension.valueString!.valueString;\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update type checking"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nswitch (value.runtimeType) {\n  case FhirString:\n    // ...\n  case FhirBoolean:\n    // ...\n}\n\n// New - Use getters\nif (extension.valueString != null) {\n  // It's a string\n} else if (extension.valueBoolean != null) {\n  // It's a boolean\n} else if (extension.valueInteger != null) {\n  // It's an integer\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"serialization-and-deserialization",children:"Serialization and Deserialization"}),"\n",(0,s.jsx)(n.p,{children:"Both packages support JSON, but the new package adds YAML and convenience methods."}),"\n",(0,s.jsx)(n.h3,{id:"json-serialization",children:"JSON Serialization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old Package:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// To JSON Map\nfinal json = patient.toJson();\n\n// To JSON String (two steps)\nfinal jsonString = jsonEncode(patient.toJson());\n\n// From JSON\nfinal patient = Patient.fromJson(jsonMap);\n\n// From JSON String (two steps)\nfinal jsonMap = jsonDecode(jsonString);\nfinal patient = Patient.fromJson(jsonMap);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New Package:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// To JSON Map (same)\nfinal json = patient.toJson();\n\n// To JSON String (one step!)\nfinal jsonString = patient.toJsonString();\n\n// From JSON (same)\nfinal patient = Patient.fromJson(jsonMap);\n\n// From JSON String (one step!)\nfinal patient = Patient.fromJsonString(jsonString);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"yaml-support-new",children:"YAML Support (New!)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// To YAML String\nfinal yamlString = patient.toYaml();\n\n// From YAML\nfinal patient = Patient.fromYaml(yamlString);\n// OR\nfinal patient = Patient.fromYaml(yamlMap);  // YamlMap\n"})}),"\n",(0,s.jsx)(n.h3,{id:"migration-steps",children:"Migration Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replace two-step JSON string serialization"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nfinal jsonString = jsonEncode(patient.toJson());\n\n// New\nfinal jsonString = patient.toJsonString();\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replace two-step JSON string deserialization"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old\nfinal patient = Patient.fromJson(jsonDecode(jsonString));\n\n// New\nfinal patient = Patient.fromJsonString(jsonString);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider adding YAML support"})," where it makes sense (debugging, configuration, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"utility-methods",children:"Utility Methods"}),"\n",(0,s.jsx)(n.p,{children:"The new package includes powerful reflection-like utilities that weren't in the old package."}),"\n",(0,s.jsx)(n.h3,{id:"new-utility-methods",children:"New Utility Methods"}),"\n",(0,s.jsxs)(n.h4,{id:"1-listchildrennames",children:["1. ",(0,s.jsx)(n.code,{children:"listChildrenNames()"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Get all field names\nfinal fieldNames = patient.listChildrenNames();\n// Returns: ['id', 'meta', 'implicitRules', 'language', 'text', 'contained', ...]\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2-getchildrenbynamestring-name",children:["2. ",(0,s.jsx)(n.code,{children:"getChildrenByName(String name)"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Get specific fields by name\nfinal names = patient.getChildrenByName('name');\n// Returns: List<FhirBase> containing all name values\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"3-getchildbynamestring-name",children:["3. ",(0,s.jsx)(n.code,{children:"getChildByName(String name)"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Get a single field by name\nfinal id = patient.getChildByName('id');\n// Returns: FhirBase? (the id field)\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"4-copywith",children:["4. ",(0,s.jsx)(n.code,{children:"copyWith()"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Create modified copies (improved from old package)\nfinal updatedPatient = patient.copyWith(\n  id: '456'.toFhirId,\n  active: true.toFhirBoolean,\n);\n\n// New: Can now pass null to clear fields!\nfinal patientWithoutName = patient.copyWith(\n  name: null,  // This now works!\n);\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"5-equalsdeep",children:["5. ",(0,s.jsx)(n.code,{children:"equalsDeep()"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Deep equality comparison\nfinal areEqual = patient1.equalsDeep(patient2);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"migration-benefit",children:"Migration Benefit"}),"\n",(0,s.jsx)(n.p,{children:"These new methods can simplify a lot of dynamic field access code you might have written in the old package."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example - Dynamic Field Access:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old package - Had to know exact structure\nString? getPatientName(Patient patient) {\n  if (patient.name != null && patient.name!.isNotEmpty) {\n    return patient.name!.first.family?.value;\n  }\n  return null;\n}\n\n// New package - Can use reflection-like methods\nList<FhirBase> getFieldByName(Patient patient, String fieldName) {\n  return patient.getChildrenByName(fieldName);\n}\n\n// Get all field names for introspection\nvoid printAllFields(Patient patient) {\n  for (final fieldName in patient.listChildrenNames()) {\n    print('$fieldName: ${patient.getChildrenByName(fieldName)}');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"common-migration-patterns",children:"Common Migration Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"pattern-1-accessing-nested-primitive-values",children:"Pattern 1: Accessing Nested Primitive Values"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final patientName = patient.name?.first.given?.first.value;\nfinal birthDate = patient.birthDate?.value;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final patientName = patient.name?.first.given?.first.valueString;\nfinal birthDate = patient.birthDate?.valueDateTime;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-2-creating-resources-with-primitives",children:"Pattern 2: Creating Resources with Primitives"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final observation = Observation(\n  status: ObservationStatus.final_,\n  code: CodeableConcept(\n    coding: [\n      Coding(\n        system: FhirUri('http://loinc.org'),\n        code: FhirCode('8480-6'),\n        display: FhirString('Systolic blood pressure'),\n      ),\n    ],\n  ),\n  valueQuantity: Quantity(\n    value: FhirDecimal(120),\n    unit: FhirString('mmHg'),\n    system: FhirUri('http://unitsofmeasure.org'),\n    code: FhirCode('mm[Hg]'),\n  ),\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New (same structure, but consider extension methods):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final observation = Observation(\n  status: ObservationStatus.final_,\n  code: CodeableConcept(\n    coding: [\n      Coding(\n        system: 'http://loinc.org'.toFhirUri,\n        code: '8480-6'.toFhirCode,\n        display: 'Systolic blood pressure'.toFhirString,\n      ),\n    ],\n  ),\n  valueQuantity: Quantity(\n    value: 120.0.toFhirDecimal,\n    unit: 'mmHg'.toFhirString,\n    system: 'http://unitsofmeasure.org'.toFhirUri,\n    code: 'mm[Hg]'.toFhirCode,\n  ),\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-3-checking-for-null-values",children:"Pattern 3: Checking for Null Values"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"if (patient.name != null && \n    patient.name!.first.family != null && \n    patient.name!.first.family!.value != null) {\n  print(patient.name!.first.family!.value);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Same null checking needed\nif (patient.name != null && \n    patient.name!.first.family != null && \n    patient.name!.first.family!.valueString != null) {\n  print(patient.name!.first.family!.valueString);\n}\n\n// OR use null-aware operators\nfinal familyName = patient.name?.first.family?.valueString;\nif (familyName != null) {\n  print(familyName);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-4-working-with-lists",children:"Pattern 4: Working with Lists"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final identifiers = patient.identifier?.map((id) => id.value?.value).toList();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final identifiers = patient.identifier?.map((id) => id.value?.valueString).toList();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-5-polymorphic-extensions",children:"Pattern 5: Polymorphic Extensions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Old:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final extension = FhirExtension(\n  url: FhirUri('http://example.org/height'),\n  value: Quantity(\n    value: FhirDecimal(175),\n    unit: FhirString('cm'),\n  ),\n);\n\n// Accessing\nif (extension.value is Quantity) {\n  final quantity = extension.value as Quantity;\n  final value = quantity.value?.value;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"New:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final extension = FhirExtension(\n  url: 'http://example.org/height'.toFhirUri,\n  valueX: Quantity(\n    value: 175.0.toFhirDecimal,\n    unit: 'cm'.toFhirString,\n  ),\n);\n\n// Accessing - Much cleaner!\nfinal quantity = extension.valueQuantity;\nif (quantity != null) {\n  final value = quantity.value?.valueDecimal;\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"breaking-changes-checklist",children:"Breaking Changes Checklist"}),"\n",(0,s.jsx)(n.p,{children:"Use this checklist to systematically update your code:"}),"\n",(0,s.jsx)(n.h3,{id:"1-imports",children:"1. Imports"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace ",(0,s.jsx)(n.code,{children:"import 'package:fhir/fhir.dart'"})," with ",(0,s.jsx)(n.code,{children:"import 'package:fhir_r4/fhir_r4.dart'"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update pubspec.yaml"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-primitive-types",children:"2. Primitive Types"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Find all ",(0,s.jsx)(n.code,{children:".value"})," accessors on FHIR primitive types"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace with appropriate typed getters (",(0,s.jsx)(n.code,{children:".valueString"}),", ",(0,s.jsx)(n.code,{children:".valueInteger"}),", ",(0,s.jsx)(n.code,{children:".valueBoolean"}),", etc.)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update any primitive type constructors if using element/extensions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-enums",children:"3. Enums"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace string literal enum values with FhirCodeEnum values"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update equality checks to use enum values"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Convert switch statements to use native enums via ",(0,s.jsx)(n.code,{children:".valueEnum"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-polymorphic-fields",children:"4. Polymorphic Fields"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Identify all polymorphic fields (those that can be multiple types)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Rename field access to add ",(0,s.jsx)(n.code,{children:"X"})," suffix (e.g., ",(0,s.jsx)(n.code,{children:"value"})," \u2192 ",(0,s.jsx)(n.code,{children:"valueX"}),")"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use type-specific getters instead of casting"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update type checking logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-serialization",children:"5. Serialization"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace ",(0,s.jsx)(n.code,{children:"jsonEncode(resource.toJson())"})," with ",(0,s.jsx)(n.code,{children:"resource.toJsonString()"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace ",(0,s.jsx)(n.code,{children:"Resource.fromJson(jsonDecode(string))"})," with ",(0,s.jsx)(n.code,{children:"Resource.fromJsonString(string)"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Consider adding YAML support where useful"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"6-testing",children:"6. Testing"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update all tests that check primitive values"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update JSON serialization/deserialization tests"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add tests for new utility methods if using them"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test enum comparisons"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"7-consider-adopting-new-features",children:"7. Consider Adopting New Features"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use extension methods for primitive type creation"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use ",(0,s.jsx)(n.code,{children:"copyWith()"})," with null values where needed"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Leverage ",(0,s.jsx)(n.code,{children:"listChildrenNames()"})," and ",(0,s.jsx)(n.code,{children:"getChildrenByName()"})," for dynamic access"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use YAML for debugging/configuration"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"step-by-step-migration-process",children:"Step-by-Step Migration Process"}),"\n",(0,s.jsx)(n.h3,{id:"phase-1-setup-30-minutes",children:"Phase 1: Setup (30 minutes)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a new branch for migration"}),"\n",(0,s.jsx)(n.li,{children:"Update pubspec.yaml"}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"flutter pub get"})]}),"\n",(0,s.jsx)(n.li,{children:"Update all imports"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2-fix-compilation-errors-2-4-hours-depending-on-codebase-size",children:"Phase 2: Fix Compilation Errors (2-4 hours depending on codebase size)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Start with primitive value accessors:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Search for ",(0,s.jsx)(n.code,{children:".value"})," globally"]}),"\n",(0,s.jsx)(n.li,{children:"For each FHIR primitive type, replace with appropriate getter"}),"\n",(0,s.jsx)(n.li,{children:"Start with most common types first (FhirString, FhirId, FhirCode)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fix polymorphic fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Search for known polymorphic field names"}),"\n",(0,s.jsxs)(n.li,{children:["Add ",(0,s.jsx)(n.code,{children:"X"})," suffix"]}),"\n",(0,s.jsx)(n.li,{children:"Update accessors to use type-specific getters"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Update enums:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Replace string literals with enum values"}),"\n",(0,s.jsx)(n.li,{children:"Update comparisons"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fix serialization:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Replace two-step JSON operations with convenience methods"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3-testing-1-2-hours",children:"Phase 3: Testing (1-2 hours)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Run all existing tests"}),"\n",(0,s.jsx)(n.li,{children:"Fix any test failures"}),"\n",(0,s.jsx)(n.li,{children:"Add tests for new patterns if needed"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-4-optimization-optional-1-2-hours",children:"Phase 4: Optimization (optional, 1-2 hours)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Adopt extension methods for cleaner code"}),"\n",(0,s.jsx)(n.li,{children:"Use new utility methods where beneficial"}),"\n",(0,s.jsx)(n.li,{children:"Add YAML support for debugging"}),"\n",(0,s.jsx)(n.li,{children:"Update documentation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"quick-reference-table",children:"Quick Reference Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Task"}),(0,s.jsx)(n.th,{children:"Old Package"}),(0,s.jsx)(n.th,{children:"New Package"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Get string value"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueString"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Get int value"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueInteger"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Get bool value"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueBoolean"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Get DateTime value"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueDateTime"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Get double value"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".value"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".valueDecimal"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Create FhirString"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FhirString('text')"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'text'.toFhirString"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Create FhirDate"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FhirDate('2024-01-01')"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'2024-01-01'.toFhirDate"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Enum comparison"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"status == 'active'"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"status == Status.active"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Polymorphic field"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:".value"})," or ",(0,s.jsx)(n.code,{children:".product"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:".valueX"})," or ",(0,s.jsx)(n.code,{children:".productX"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Type-specific getter"}),(0,s.jsx)(n.td,{children:"Cast required"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:".valueString"}),", ",(0,s.jsx)(n.code,{children:".valueInteger"}),", etc."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON to string"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"jsonEncode(x.toJson())"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"x.toJsonString()"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"String to JSON"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"X.fromJson(jsonDecode(s))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"X.fromJsonString(s)"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"YAML support"}),(0,s.jsx)(n.td,{children:"Not available"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:".toYaml()"}),", ",(0,s.jsx)(n.code,{children:".fromYaml()"})]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-common-errors",children:"Troubleshooting Common Errors"}),"\n",(0,s.jsx)(n.h3,{id:"error-the-getter-value-isnt-defined",children:"Error: \"The getter 'value' isn't defined\""}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Using old ",(0,s.jsx)(n.code,{children:".value"})," accessor on primitive type."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Replace with typed getter:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Error\nfinal name = patient.name?.first.family?.value;\n\n// Fix\nfinal name = patient.name?.first.family?.valueString;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"error-the-argument-type-string-cant-be-assigned-to-the-parameter-type-appointmentstatus",children:"Error: \"The argument type 'String' can't be assigned to the parameter type 'AppointmentStatus'\""}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Trying to use string literal where enum is expected."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Use the enum value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Error\nfinal appointment = Appointment(status: 'booked');\n\n// Fix\nfinal appointment = Appointment(status: AppointmentStatus.booked);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"error-the-getter-product-isnt-defined",children:"Error: \"The getter 'product' isn't defined\""}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Polymorphic field name changed."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Add ",(0,s.jsx)(n.code,{children:"X"})," suffix:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Error\nfinal product = carePlan.detail?.first.product;\n\n// Fix\nfinal product = carePlan.detail?.first.productX;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"error-the-operator--isnt-defined-for-the-type",children:"Error: \"The operator '==' isn't defined for the type\""}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cause:"})," Enum comparison issue."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Use proper enum comparison:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Error (comparing incompatible types)\nif (status == 'active') { }\n\n// Fix\nif (status == AppointmentStatus.booked) { }\n// OR\nif (status?.valueEnum == AppointmentStatusEnum.booked) { }\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-complete-migration",children:"Example: Complete Migration"}),"\n",(0,s.jsx)(n.h3,{id:"before-old-package",children:"Before (Old Package)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir/fhir.dart';\n\nvoid createPatient() {\n  final patient = Patient(\n    id: FhirId('patient-123'),\n    name: [\n      HumanName(\n        family: FhirString('Smith'),\n        given: [FhirString('John')],\n      ),\n    ],\n    gender: 'male',\n    birthDate: FhirDate('1980-05-15'),\n    active: FhirBoolean(true),\n  );\n\n  // Accessing values\n  final id = patient.id?.value;\n  final lastName = patient.name?.first.family?.value;\n  final firstName = patient.name?.first.given?.first.value;\n  final birthDate = patient.birthDate?.value;\n  final isActive = patient.active?.value;\n  \n  // Gender check\n  if (patient.gender == 'male') {\n    print('Male patient');\n  }\n\n  // Serialization\n  final jsonString = jsonEncode(patient.toJson());\n  \n  // Deserialization\n  final patientCopy = Patient.fromJson(jsonDecode(jsonString));\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"after-new-package",children:"After (New Package)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:fhir_r4/fhir_r4.dart';\n\nvoid createPatient() {\n  final patient = Patient(\n    id: '123'.toFhirId,  // Using extension method\n    name: [\n      HumanName(\n        family: 'Smith'.toFhirString,\n        given: ['John'.toFhirString],\n      ),\n    ],\n    gender: AdministrativeGender.male,  // Using enum\n    birthDate: '1980-05-15'.toFhirDate,\n    active: true.toFhirBoolean,\n  );\n\n  // Accessing values - Note the different getters!\n  final id = patient.id?.valueString;  // Changed!\n  final lastName = patient.name?.first.family?.valueString;  // Changed!\n  final firstName = patient.name?.first.given?.first.valueString;  // Changed!\n  final birthDate = patient.birthDate?.valueDateTime;  // Changed!\n  final isActive = patient.active?.valueBoolean;  // Changed!\n  \n  // Gender check using enum\n  if (patient.gender == AdministrativeGender.male) {\n    print('Male patient');\n  }\n  \n  // OR using native enum for switch\n  switch (patient.gender?.valueEnum) {\n    case AdministrativeGenderEnum.male:\n      print('Male patient');\n      break;\n    case AdministrativeGenderEnum.female:\n      print('Female patient');\n      break;\n    case AdministrativeGenderEnum.other:\n    case AdministrativeGenderEnum.unknown:\n    case null:\n      print('Other/Unknown gender');\n      break;\n  }\n\n  // Serialization - One step!\n  final jsonString = patient.toJsonString();\n  \n  // Deserialization - One step!\n  final patientCopy = Patient.fromJsonString(jsonString);\n  \n  // New: YAML support\n  final yamlString = patient.toYaml();\n  print(yamlString);  // Pretty-printed YAML\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getting-help",children:"Getting Help"}),"\n",(0,s.jsx)(n.p,{children:"If you run into issues during migration:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Check the documentation"})," at the new package's repository"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Look at the generated code"})," - The new package is heavily documented"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use your IDE's type system"})," - Hover over methods to see return types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Search for similar patterns"})," in this guide"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create minimal reproducible examples"})," when asking for help"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["The migration from the old ",(0,s.jsx)(n.code,{children:"fhir"})," package to ",(0,s.jsx)(n.code,{children:"fhir_r4"})," involves these key changes:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitive type accessors"}),": ",(0,s.jsx)(n.code,{children:".value"})," \u2192 ",(0,s.jsx)(n.code,{children:".valueString"})," (or ",(0,s.jsx)(n.code,{children:".valueInteger"}),", ",(0,s.jsx)(n.code,{children:".valueBoolean"}),", etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enum handling"}),": String literals \u2192 FhirCodeEnum values with native enum support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polymorphic fields"}),": Add ",(0,s.jsx)(n.code,{children:"X"})," suffix and use type-specific getters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serialization"}),": Use convenience methods (",(0,s.jsx)(n.code,{children:".toJsonString()"}),", ",(0,s.jsx)(n.code,{children:".fromJsonString()"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"New utilities"}),": ",(0,s.jsx)(n.code,{children:"listChildrenNames()"}),", ",(0,s.jsx)(n.code,{children:"getChildrenByName()"}),", improved ",(0,s.jsx)(n.code,{children:"copyWith()"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"While there are breaking changes, the migration is straightforward and systematic. Most errors will be caught at compile-time, making the process safe. The new package offers better type safety, cleaner syntax, and more powerful features that will make your FHIR code more maintainable."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Estimated migration time:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Small project (< 1000 lines): 2-3 hours"}),"\n",(0,s.jsx)(n.li,{children:"Medium project (1000-5000 lines): 4-8 hours"}),"\n",(0,s.jsx)(n.li,{children:"Large project (5000+ lines): 1-2 days"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The investment is worth it for the improved developer experience and type safety!"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"New package documentation (check project README)"}),"\n",(0,s.jsxs)(n.li,{children:["FHIR R4 specification: ",(0,s.jsx)(n.a,{href:"https://hl7.org/fhir/R4/",children:"https://hl7.org/fhir/R4/"})]}),"\n",(0,s.jsx)(n.li,{children:"FHIRPath documentation (for integration with fhir_path package)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Good luck with your migration! \ud83d\ude80"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);