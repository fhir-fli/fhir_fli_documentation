"use strict";(self.webpackChunkfhir_fli_documentation=self.webpackChunkfhir_fli_documentation||[]).push([[764],{1291:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var t=i(4848),r=i(8453);const a={id:"primitive_types",title:"Primitive Types"},s=void 0,l={id:"core/primitive_types",title:"Primitive Types",description:"---",source:"@site/docs/core/primitive_types.md",sourceDirName:"core",slug:"/core/primitive_types",permalink:"/fhir_fli_documentation/docs/core/primitive_types",draft:!1,unlisted:!1,editUrl:"https://github.com/fhir-fli/fhir_fli_documentation/tree/main/docs/core/primitive_types.md",tags:[],version:"current",frontMatter:{id:"primitive_types",title:"Primitive Types"},sidebar:"tutorialSidebar",previous:{title:"Polymprhic Types",permalink:"/fhir_fli_documentation/docs/core/polymorphic_types"},next:{title:"Enums",permalink:"/fhir_fli_documentation/docs/core/enums"}},o={},d=[{value:"id: primitive_types\ntitle: Primitive Types",id:"id-primitive_typestitle-primitive-types",level:2},{value:"Understanding FHIR Primitive Types",id:"understanding-fhir-primitive-types",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"Internal Representation",id:"internal-representation",level:3},{value:"Element Metadata",id:"element-metadata",level:3},{value:"Common Primitive Type Structure",id:"common-primitive-type-structure",level:2},{value:"Working with Primitive Types",id:"working-with-primitive-types",level:2},{value:"Creating Primitive Types",id:"creating-primitive-types",level:3},{value:"Reading Values",id:"reading-values",level:3},{value:"Value-only vs Element-only vs Both",id:"value-only-vs-element-only-vs-both",level:3},{value:"Specific Primitive Types",id:"specific-primitive-types",level:2},{value:"Boolean (FhirBoolean)",id:"boolean-fhirboolean",level:3},{value:"String Types (FhirString, FhirCode, FhirId, FhirMarkdown, etc.)",id:"string-types-fhirstring-fhircode-fhirid-fhirmarkdown-etc",level:3},{value:"URI Types (FhirUri, FhirUrl, FhirCanonical, FhirOid)",id:"uri-types-fhiruri-fhirurl-fhircanonical-fhiroid",level:3},{value:"Numeric Types (FhirInteger, FhirDecimal, etc.)",id:"numeric-types-fhirinteger-fhirdecimal-etc",level:3},{value:"Date and Time Types",id:"date-and-time-types",level:3},{value:"Date/Time Precision and Comparisons",id:"datetime-precision-and-comparisons",level:2},{value:"JSON Serialization: The FHIR Element Pattern",id:"json-serialization-the-fhir-element-pattern",level:2},{value:"The &quot;_value&quot; Pattern",id:"the-_value-pattern",level:3},{value:"How FHIR-FLI Implements This Pattern",id:"how-fhir-fli-implements-this-pattern",level:3},{value:"Special Handling in Resources",id:"special-handling-in-resources",level:3},{value:"List Handling",id:"list-handling",level:3},{value:"Important Considerations",id:"important-considerations",level:3},{value:"Polymorphic Usage",id:"polymorphic-usage",level:2},{value:"Utility Methods",id:"utility-methods",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"id-primitive_typestitle-primitive-types",children:"id: primitive_types\ntitle: Primitive Types"}),"\n",(0,t.jsx)(n.h1,{id:"primitive-types-in-fhir-fli",children:"Primitive Types in FHIR-FLI"}),"\n",(0,t.jsx)(n.h2,{id:"understanding-fhir-primitive-types",children:"Understanding FHIR Primitive Types"}),"\n",(0,t.jsx)(n.p,{children:"Primitive types are the fundamental building blocks of FHIR resources. While they appear simple (booleans, strings, numbers, etc.), FHIR defines specific validation rules and formats for each primitive type that differ from standard Dart types. FHIR-FLI implements these with strong typing and additional functionality."}),"\n",(0,t.jsx)(n.p,{children:"In FHIR-FLI, all primitive types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Are subclasses of ",(0,t.jsx)(n.code,{children:"PrimitiveType"}),", which extends ",(0,t.jsx)(n.code,{children:"FhirBase"})]}),"\n",(0,t.jsx)(n.li,{children:"Store their values internally as strings for consistent serialization"}),"\n",(0,t.jsxs)(n.li,{children:["Include optional metadata via the ",(0,t.jsx)(n.code,{children:"Element"})," class"]}),"\n",(0,t.jsx)(n.li,{children:"Provide appropriate getters to access values in their natural Dart types"}),"\n",(0,t.jsx)(n.li,{children:"Support polymorphism and can be used in various resource fields"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"internal-representation",children:"Internal Representation"}),"\n",(0,t.jsx)(n.p,{children:"All FHIR primitive types in FHIR-FLI store their primary value as a string:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Inside PrimitiveType class\nfinal String? valueString;\n"})}),"\n",(0,t.jsx)(n.p,{children:"This approach ensures consistent serialization and supports FHIR's extensibility model. When you create a primitive type instance, your input value is validated and converted to a string representation."}),"\n",(0,t.jsx)(n.h3,{id:"element-metadata",children:"Element Metadata"}),"\n",(0,t.jsxs)(n.p,{children:["FHIR primitive types can include an ",(0,t.jsx)(n.code,{children:"Element"})," instance that contains metadata like extensions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Inside PrimitiveType class\nfinal Element? element;\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows primitives to carry extensions and other metadata alongside their core value."}),"\n",(0,t.jsx)(n.h2,{id:"common-primitive-type-structure",children:"Common Primitive Type Structure"}),"\n",(0,t.jsx)(n.p,{children:"All primitive types follow a consistent pattern:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extension methods"})," on relevant Dart types for easy conversion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Private constructor"})," for internal use"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Public factories"})," for instance creation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JSON/YAML constructors"})," for serialization/deserialization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Convenience getters"})," for accessing the value in appropriate Dart types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Boolean state checkers"})," for checking value/element presence"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Utility methods"})," for manipulation and comparison"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's a class diagram showing the inheritance and common interface for primitive types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"FhirBase\n   |\n   +--\x3e PrimitiveType\n            |\n            +--\x3e FhirBoolean\n            +--\x3e FhirDecimal\n            +--\x3e FhirInteger\n            +--\x3e FhirString\n            +--\x3e FhirUri\n            +--\x3e FhirDateTime\n            +--\x3e FhirDate\n            +--\x3e FhirTime\n            +--\x3e FhirInstant\n            ...\n"})}),"\n",(0,t.jsx)(n.h2,{id:"working-with-primitive-types",children:"Working with Primitive Types"}),"\n",(0,t.jsx)(n.h3,{id:"creating-primitive-types",children:"Creating Primitive Types"}),"\n",(0,t.jsx)(n.p,{children:"You can create primitive types in several ways:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Direct constructor with native type\nfinal myBoolean = FhirBoolean(true);\nfinal myDecimal = FhirDecimal(42.5);\n\n// From string representation\nfinal myUri = FhirUri('http://example.org');\n\n// Using extension methods\nfinal boolFromNative = true.toFhirBoolean;\nfinal uriFromNative = 'http://example.org'.toFhirUri;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reading-values",children:"Reading Values"}),"\n",(0,t.jsx)(n.p,{children:"Each primitive type provides typed getters to access its value in the appropriate Dart type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Boolean example\nfinal bool? nativeValue = myBoolean.valueBoolean;\n\n// DateTime example\nfinal DateTime? dateTimeValue = myFhirDateTime.valueDateTime;\n\n// Uri example\nfinal Uri? uriValue = myUri.valueUri;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"value-only-vs-element-only-vs-both",children:"Value-only vs Element-only vs Both"}),"\n",(0,t.jsx)(n.p,{children:"FHIR primitives can exist in three states:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Value-only"}),": Contains just the primitive value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Element-only"}),": Contains just metadata (extensions)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Value and Element"}),": Contains both value and metadata"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Helper properties let you check which state applies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"if (myBoolean.valueOnly) {\n  // Just a boolean value, no extensions\n}\n\nif (myBoolean.hasElementOnly) {\n  // Contains extensions but no value\n}\n\nif (myBoolean.valueAndElement) {\n  // Contains both a value and extensions\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"specific-primitive-types",children:"Specific Primitive Types"}),"\n",(0,t.jsx)(n.h3,{id:"boolean-fhirboolean",children:"Boolean (FhirBoolean)"}),"\n",(0,t.jsxs)(n.p,{children:["Represents FHIR ",(0,t.jsx)(n.code,{children:"boolean"})," type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Creating a boolean\nfinal myBoolean = FhirBoolean(true);\n\n// Using extension method\nfinal myBoolean2 = true.toFhirBoolean;\n\n// Accessing the value\nfinal bool? value = myBoolean.valueBoolean;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"string-types-fhirstring-fhircode-fhirid-fhirmarkdown-etc",children:"String Types (FhirString, FhirCode, FhirId, FhirMarkdown, etc.)"}),"\n",(0,t.jsx)(n.p,{children:"Various string-based types with different validation rules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Creating string types\nfinal myString = FhirString('Hello, FHIR!');\nfinal myCode = FhirCode('active');\nfinal myId = FhirId('patient-123');\n\n// Using extension method\nfinal myString2 = 'Hello, FHIR!'.toFhirString;\n\n// Accessing values\nfinal String? stringValue = myString.value;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"uri-types-fhiruri-fhirurl-fhircanonical-fhiroid",children:"URI Types (FhirUri, FhirUrl, FhirCanonical, FhirOid)"}),"\n",(0,t.jsx)(n.p,{children:"URI-based types with different validation rules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Creating URI types\nfinal myUri = FhirUri('http://example.org');\nfinal myUrl = FhirUrl('http://example.org/fhir/Patient/123');\n\n// From Uri object\nfinal dartUri = Uri.parse('http://example.org');\nfinal myUri2 = dartUri.toFhirUri;\n\n// Using extension method\nfinal myUri3 = 'http://example.org'.toFhirUri;\n\n// Accessing values\nfinal Uri? uriValue = myUri.valueUri;\nfinal String? stringValue = myUri.valueString;\n\n// Additional URI helpers\nfinal host = myUri.host;         // 'example.org'\nfinal pathSegments = myUri.pathSegments;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"numeric-types-fhirinteger-fhirdecimal-etc",children:"Numeric Types (FhirInteger, FhirDecimal, etc.)"}),"\n",(0,t.jsx)(n.p,{children:"Various numeric types with different validation rules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Creating numeric types\nfinal myInteger = FhirInteger(42);\nfinal myDecimal = FhirDecimal(3.14159);\nfinal myPositiveInt = FhirPositiveInt(10);\n\n// Using extension methods\nfinal myInt2 = 42.toFhirInteger;\nfinal myDecimal2 = 3.14159.toFhirDecimal;\n\n// Accessing values\nfinal int? intValue = myInteger.valueInteger;\nfinal double? decimalValue = myDecimal.valueDecimal;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"date-and-time-types",children:"Date and Time Types"}),"\n",(0,t.jsx)(n.p,{children:"FHIR has multiple date/time types, all inherited from a common base:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Creating date/time types\nfinal myDateTime = FhirDateTime('2023-06-15T13:30:45Z');\nfinal myDate = FhirDate('2023-06-15');\nfinal myTime = FhirTime('13:30:45');\nfinal myInstant = FhirInstant('2023-06-15T13:30:45.123Z');\n\n// From DateTime object\nfinal dartDateTime = DateTime.now();\nfinal myDateTime2 = dartDateTime.toFhirDateTime;\n\n// Using extension methods\nfinal myDateTime3 = '2023-06-15T13:30:45Z'.toFhirDateTime;\n\n// Accessing components\nfinal int? year = myDateTime.year;\nfinal int? month = myDateTime.month;\nfinal int? day = myDateTime.day;\nfinal int? hour = myDateTime.hour;\n\n// Accessing as DateTime\nfinal DateTime? dateTimeValue = myDateTime.valueDateTime;\n\n// Comparing dates\nif (myDateTime > someOtherDateTime) {\n  // Date comparison\n}\n\n// Arithmetic with dates (using ExtendedDuration)\nfinal oneWeekLater = myDateTime + ExtendedDuration(weeks: 1);\nfinal oneDayEarlier = myDateTime - ExtendedDuration(days: 1);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"datetime-precision-and-comparisons",children:"Date/Time Precision and Comparisons"}),"\n",(0,t.jsx)(n.p,{children:"FHIR date/time types follow FHIRPath rules for precision when comparing values. For example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A date-only value (",(0,t.jsx)(n.code,{children:"2023-06-15"}),") represents the entire day"]}),"\n",(0,t.jsxs)(n.li,{children:["A date-time without seconds (",(0,t.jsx)(n.code,{children:"2023-06-15T13:30"}),") represents the entire minute"]}),"\n",(0,t.jsx)(n.li,{children:"Comparing values with different precisions follows specific rules"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Per FHIRPath rules, comparing different precision levels returns null (empty)\nfinal dateOnly = FhirDate('2023-06-15');\nfinal dateTimeWithHour = FhirDateTime('2023-06-15T13:00:00');\n\ndateTimeWithHour > dateOnly; // returns null, not true\ndateTimeWithHour == dateOnly; // returns null, not true or false\n"})}),"\n",(0,t.jsx)(n.h2,{id:"json-serialization-the-fhir-element-pattern",children:"JSON Serialization: The FHIR Element Pattern"}),"\n",(0,t.jsx)(n.p,{children:"FHIR primitive types have a unique serialization pattern that stems from FHIR's XML origins. In XML, primitives can have attributes (like extensions), but JSON doesn't have a native way to attach metadata to primitives. FHIR solves this with a special pattern:"}),"\n",(0,t.jsx)(n.h3,{id:"the-_value-pattern",children:'The "_value" Pattern'}),"\n",(0,t.jsx)(n.p,{children:"For every primitive field in FHIR JSON, there can be a corresponding metadata field with the same name prefixed by an underscore:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "active": true,         // The primitive value\n  "_active": {            // The Element with metadata for "active"\n    "extension": [{\n      "url": "http://example.org/some-extension",\n      "valueString": "Some extension value"\n    }]\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-fhir-fli-implements-this-pattern",children:"How FHIR-FLI Implements This Pattern"}),"\n",(0,t.jsx)(n.p,{children:"FHIR-FLI's primitive types implement special JSON handling to support this pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Serializing to JSON\nfinal myBoolean = FhirBoolean(true);\nmyBoolean.toJson();  // Returns: {\"value\": true}\n\n// With extensions\nfinal myBooleanWithExt = FhirBoolean(\n  true,\n  element: Element(\n    extension_: [\n      FhirExtension(\n        url: FhirUri('http://example.org/some-extension'),\n        valueString: FhirString('Some extension value')\n      )\n    ]\n  )\n);\n\nmyBooleanWithExt.toJson();\n// Returns: {\n//   \"value\": true,\n//   \"_value\": {\n//     \"extension\": [{\n//       \"url\": \"http://example.org/some-extension\",\n//       \"valueString\": \"Some extension value\"\n//     }]\n//   }\n// }\n\n// Deserializing from JSON\nfinal myBooleanFromJson = FhirBoolean.fromJson({\n  'value': true,\n  '_value': {\n    'extension': [\n      {\n        'url': 'http://example.org/some-extension',\n        'valueString': 'Some extension value'\n      }\n    ]\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"special-handling-in-resources",children:"Special Handling in Resources"}),"\n",(0,t.jsxs)(n.p,{children:["When primitive types are used within FHIR resources, the resource's ",(0,t.jsx)(n.code,{children:"toJson()"})," and ",(0,t.jsx)(n.code,{children:"fromJson()"})," methods automatically handle the field name transformation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:'// Resource with primitive fields\nfinal patient = Patient(\n  active: FhirBoolean(true, \n    element: Element(extension_: [someExtension])\n  ),\n  // other fields...\n);\n\npatient.toJson();\n// Returns: {\n//   "resourceType": "Patient",\n//   "active": true,\n//   "_active": {\n//     "extension": [...]\n//   },\n//   // other fields...\n// }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"list-handling",children:"List Handling"}),"\n",(0,t.jsx)(n.p,{children:"For lists of primitives, FHIR uses parallel arrays:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:'// JSON representation\n{\n  "name": ["John", "Johnny", "J"],  // Values array\n  "_name": [                        // Parallel metadata array\n    null,                           // No metadata for "John"\n    {                               // Metadata for "Johnny"\n      "extension": [...]\n    },\n    null                            // No metadata for "J"\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"FHIR-FLI handles this with special list methods:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:'// Create a list of primitives with metadata\nfinal names = [\n  FhirString("John"),\n  FhirString("Johnny", element: Element(extension_: [...])),\n  FhirString("J")\n];\n\n// Convert to parallel arrays JSON\nfinal json = FhirString.toJsonList(names);\n// Returns: {\n//   "value": ["John", "Johnny", "J"],\n//   "_value": [null, {...}, null]\n// }\n\n// Parse from parallel arrays\nfinal parsedNames = FhirString.fromJsonList(\n  json[\'value\'] as List<dynamic>,\n  json[\'_value\'] as List<dynamic>?\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Different from Other Classes"}),": Primitive types have special JSON handling that differs from other FHIR classes to accommodate the FHIR JSON specification."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Field Names"}),": Within resources, the field name is used for the value and ",(0,t.jsx)(n.code,{children:"_fieldName"})," for metadata. Inside primitive types, these become ",(0,t.jsx)(n.code,{children:"value"})," and ",(0,t.jsx)(n.code,{children:"_value"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Automatic Handling"}),": Resource classes automatically handle this transformation, so it's only relevant when directly using primitive types' JSON methods."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Complete Serialization"}),": This approach ensures all metadata (extensions, etc.) is properly preserved when serializing/deserializing FHIR resources."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"polymorphic-usage",children:"Polymorphic Usage"}),"\n",(0,t.jsx)(n.p,{children:"Primitive types implement various interfaces to support polymorphic fields:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Example: FhirBoolean implements ValueXExtension\n// This allows it to be used in an Extension's value field\nfinal extension = FhirExtension(\n  url: FhirUri('http://example.org/my-boolean-extension'),\n  valueX: FhirBoolean(true), // Polymorphic usage\n);\n\n// You can retrieve the boolean using type-specific getters\nfinal boolValue = extension.valueBoolean?.valueBoolean;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"utility-methods",children:"Utility Methods"}),"\n",(0,t.jsx)(n.p,{children:"All primitive types include utility methods for common operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Equality checks\nif (myBoolean == anotherBoolean) { ... }\nif (myBoolean.equals(true)) { ... }  // Works with native types too\nif (myBoolean.equalsDeep(anotherBoolean)) { ... }  // Deep comparison\n\n// Cloning\nfinal clonedBoolean = myBoolean.clone();\n\n// Creating modified copies\nfinal updatedBoolean = myBoolean.copyWith(newValue: false);\n\n// Clearing fields\nfinal clearedElement = myBoolean.clear(extension_: true);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use extension methods"})," for cleaner code when converting from native types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Prefer this:\nfinal myBoolean = true.toFhirBoolean;\n\n// Over this:\nfinal myBoolean = FhirBoolean(true);\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Check for null"})," before accessing value getters:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final valueOrNull = myBoolean.valueBoolean;\nif (valueOrNull != null) {\n  // Use value\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use typed getters"})," instead of accessing ",(0,t.jsx)(n.code,{children:"valueString"})," directly:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Prefer this:\nfinal boolValue = myBoolean.valueBoolean;\n\n// Over this:\nfinal boolString = myBoolean.valueString;\nfinal boolValue = boolString == 'true';\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Be aware of date/time precision"})," when comparing values:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Different precision requires careful comparison\nif (dateTime1.year == dateTime2.year &&\n    dateTime1.month == dateTime2.month &&\n    dateTime1.day == dateTime2.day) {\n  // Same day regardless of time components\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use the appropriate type"})," for each FHIR field:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"// Use the correct type based on the FHIR specification\nfinal patient = Patient(\n  active: FhirBoolean(true),  // Boolean\n  birthDate: FhirDate('1990-01-15'),  // Date\n  telecom: [ContactPoint(\n    value: FhirString('+1-555-123-4567'),  // String\n    system: ContactPointSystem.phone,  // Code\n  )],\n);\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Comparison across different date/time types\n",(0,t.jsx)(n.strong,{children:"Solution"}),": Use the appropriate comparison methods or convert to consistent precision"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Working with extensions on primitive types\n",(0,t.jsx)(n.strong,{children:"Solution"}),": Check both ",(0,t.jsx)(n.code,{children:"valueX"})," and ",(0,t.jsx)(n.code,{children:"_valueX"})," when deserializing"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Unexpected serialization behavior\n",(0,t.jsx)(n.strong,{children:"Solution"}),": Remember that primitives serialize as both ",(0,t.jsx)(n.code,{children:"value"})," and ",(0,t.jsx)(n.code,{children:"_value"})," keys"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Lost extensions when updating values\n",(0,t.jsx)(n.strong,{children:"Solution"}),": Use ",(0,t.jsx)(n.code,{children:"copyWith()"})," to preserve extensions when changing values"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);